// 编写一个程序，找出第 n 个丑数。

// 丑数就是质因数只包含 2, 3, 5 的正整数。

// 示例:

// 输入: n = 10
// 输出: 12
// 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
// 说明:  

// 1 是丑数。
// n 不超过1690。



/**
 * @param {number} n
 * @return {number}
 */

// 三指针 加动态规划

// 其中 l1 l2 l3 分别为指针
// 实际上 l1 l2 l3 的含义是有资格同i相乘的最小丑数的位置。这里资格指的是：如果一个丑数通过乘以i可以得到下一个丑数，
// 那么这个丑数就永远失去了同i相乘的资格（没有必要再乘了），我们把使其加1 让 其指向下一个丑数即可。

// 一开始，丑数只有{1}，1可以同2，3，5相乘，取最小的1×2=2添加到丑数序列中。
// 现在丑数中有{1，2}，在上一步中，1已经同2相乘过了，所以今后没必要再比较1×2了，我们说1失去了同2相乘的资格。
// 现在1有与3，5相乘的资格，2有与2，3，5相乘的资格，但是2×3和2×5是没必要比较的，因为有比它更小的1可以同3，5相乘，所以我们只需要比较1×3，1×5，2×2。
// 依此类推，每次我们都分别比较有资格同2，3，5相乘的最小丑数，选择最小的那个作为下一个丑数，假设选择到的这个丑数是同i（i=2，3，5）相乘得到的，所以它失去了同i相乘的资格，把对应的pi++，让pi指向下一个丑数即可。



// 所有丑数的值 都可以是 之前的数（不确定那一位） 乘 2，3，5 得到 
var nthUglyNumber = function(n) {
    let dp = [1],min;
    let l1 ,l2,l3;
    l1 = l2 = l3 = 0;
    for(let i=1; i< n; i++){
        min = Math.min( dp[l1] * 2 ,dp[l2] * 3, dp[l3] * 5 );
        dp.push(min)
        if(dp[i] == dp[l1] * 2){
            l1 += 1
        }
        if(dp[i] == dp[l2] * 3){
            l2 += 1
        }
        if(dp[i] == dp[l3] * 5){
            l3 += 1
        }

    }
    return dp[n-1]
}