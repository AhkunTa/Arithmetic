# 二进制位运算

### 基础二进制 符号 ~ | & ^

1. ~ 取反符号

   > 二进制位中将 0 转化位 1 将 1 转化位 0

```
~1 = -2

1的原码
  00000000 00000000 00000000 00000001
每位取反
  11111111 11111111 11111111 11111110
符号位为负数 负数转为原码 需要 -1 并取反
-1
  11111111 11111111 11111111 11111101
取反(此处为二进制取反码 所以符号位不取反)
	10000000 00000000 00000000 00000010
即 -2
```

2. | 取或符号
   > 二进制位中只要有一个位为 true 即 1 就取 1 与 & 符号相反

```
0011 | 1100 = 1111 即 3 | 12 = 15

```

3. & 取和符号
   > 二进制位中两位都为为 true 即 1 取 1 与 | 符号相反

```
0011 & 1100 = 0000 即 3 & 12 = 0

```

4. ^ 异或符号
   > 二进制位中两位都不相同 才为 true 即一位为 0 一位为 1 才返回 1 否则返回 0

```
1100 ^ 0011 = 1111 即 3 ^ 12 = 15
```

### 补码反码

1. 二进制的最高位是符号位：0 表示正数，1 表示负数
2. 正数的原码、反码、补码都一样
3. 负数的反码 = 它的原码符号位不变，其他位取反 0 ->1 ; 1->0
4. 负数的补码 = 它的反码 +1
5. 0 的反码、补码都是 0
6. 在计算机运算的时候，都是以补码的方式来运算的

**例**

> 1 - 3 即 1 + (-3)

1. 首先全部取补码

```
1的补码
00000000 00000000 00000000 00000001
-3的补码 = -3的反码+1
-3的原码 左边第一位为符号位
10000000 00000000 00000000 00000011
-3的反码
11111111 11111111 11111111 11111100
-3的补码
11111111 11111111 11111111 11111101


```

2. 两个补码相加

```
 00000000 00000000 00000000 00000001
+
 11111111 11111111 11111111 11111101

=11111111 11111111 11111111 11111110

```

3. 取结果的原码 正数和其一样负数则减一取反

```
	11111111 11111111 11111111 11111110
-1
  11111111 11111111 11111111 11111101
取反
	10000000 00000000 00000000 00000010

注意最左边一位符号位取负数

即  -2

```

### 最大安全数 Number.MAX_SAFE_INTEGER

1. 最大安全数 为 2 \*\* 53 -1
2. IEEE754 即 IEEE 二进制浮点数算术标准 规定 ：单精确度（32 位）、双精确度（64 位）、延伸单精确度（43 比特以上，很少使用）与延伸双精确度（79 比特以上，通常以 80 位实现）
3. js Number 类型为 64 为双精度 而 64 双精度规定 **1**位为 `符号位` **11** 位为`指数位` `尾数位`为 **52** 位
4. 那么有 52 位为什么不是 2\*\* 52 -1 呢
5. 对于二进制来说， 小数点前保留一位， 规格化后始终是 1.\*\*\*, 节省了 1 bit，这个 1 并不需要保存

```javascript
  1.00000000....0000  // 1. 后有52位 其中 第一位 1 可以省略

  // 最大值
  1.11111111....1111 //  即 2 ** 53 -1

```
