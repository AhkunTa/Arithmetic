## Vue

### Vue 中双向数据绑定的实现原理

```javascript
// vue 双向绑定原理
// 实现一个双向绑定
function observe(data) {
  if (!data || typeof data !== "object") {
    return;
  }
  Object.keys(data).forEach((key, index) => {
    defineReactive(data, key, data[key]);
  });
}
function defineReactive(data, key, value) {
  // 获取递归获取子属性
  observe(value);
  let dep = new Dep();
  // 主要使用 defineProperty方法
  Object.defineProperty(data, key, {
    set: function (newVal) {
      if (value == newVal) {
        return;
      }
      console.log("set " + newVal);
      value = newVal;
      dep.notify();
    },
    get: function () {
      if (Dep.target) {
        dep.add(Dep.target);
      }
      return value;
    },
  });
}

function Dep() {
  this.subs = [];
}
Dep.prototype.add = function (sub) {
  this.subs.push(sub);
};

Dep.prototype.notify = function () {
  this.subs.forEach(sub => {
    console.log(sub);
    sub.update();
  });
};
Dep.target = null;
function Wacther(vm, prop, callback) {
  this.vm = vm;
  this.prop = prop;
  this.value = this.get();
  this.callback = callback;
}

// 观察器
Wacther.prototype = {
  update: function (val) {
    let oldVal = this.value;
    let value = this.vm.$data[this.prop];

    if (oldVal !== value) {
      this.value = value;
      this.callback(value);
    }
  },
  get: function () {
    Dep.target = this;
    let value = this.vm.$data[this.prop];
    Dep.target = null;
    return value;
  },
};

function Vue(options, prop) {
  this.$data = options.data;
  this.prop = prop;
  this.$el = document.querySelector(options.el);
  this.init();
}

Vue.prototype.init = function () {
  observe(this.$data);
  console.log(this.$data);
  this.$el.textContent = this.$data.name;

  new Wacther(this, this.prop, value => {
    this.$el.textContent = value;
  });
};

var vm = new Vue(
  {
    el: "#link",
    data: {
      name: "123456",
    },
  },
  "name"
);
```

### Vue 的生命周期

1. beforeCreate
   > 创建前 此时刚刚实例化完 Vue 事件监听 和 数据观测之前
2. created
   > 创建后 此时 完成了事件监听 和数据观测 通常用于数据初始化 在页面 created 是请求后端接口
3. beforeMount
   > 挂载前 在模板挂载之前 此时还无法操作 dom
4. mounted
   > 挂载后 此时模板 template 已经渲染完成即模板渲染成 html 在此之后可以操作 dom 节点
5. beforeUpdate
   > 更新前 发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器
6. updated
   > 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子
7. activated
   > 被 keep-alive 缓存的组件激活时调用
8. deactivated
   > 被 keep-alive 缓存的组件停用时调用
9. beforeDestroy
   > 实例销毁前 在这一步，实例仍然完全可用
10. destroyed
    > 实例销毁后 该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁
11. errorCaptured 2.5.0+
    > 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播

### Vue 组件间通信

#### 1 Provide Inject 双向绑定

```javascript
   // 父组件
  data(){
    return {
      // 父组件必须为对象等引用类型 数据将会双向绑定
      // 基础数据类型 不会双向绑定
      // 如 testData: '测试数据...'
      testData: {
        test: '测试数据...'
      }
    }
  },
  provide() {
    return {
      provideTest: this.testData,
    };
  },

  // 子组件 接收方式
  // 1
  inject: ["provideTest"],
  // 2
  inject: {
    provideTest: {
      default: "default"
    }
  },

```

#### 2 Vue.observable 双向绑定

> vue.observable 仅在 2.6 版本及以上

```javascript
// 增加 store.js文件
import Vue from "vue";
let store = Vue.observable({
  name: "111",
  age: 28,
});

let mutations = {
  addAge: function (count) {
    store.age += count;
  },
  changeName: function (name) {
    store.name = name;
  },
};
export { store, mutations };

// 在组件中引入即可 类似VUEX文件引入
```

#### 3 $props $emit

> 父组件通过 props 传递数据 子组件通过事件 $emit 来接受事件和参数

**props 数据双向绑定**

#### 4 VUEX

```javascript

```

#### 5 Bus 文件

> 和 2 类似

```javascript
// bus.js
import Vue from "vue";

export default new Vue();
// 在子组件中 通过 $on来监听
```

#### 6 $attrs $listeners 文件

> 使用方法类似 $emit 和 props

> 所有父组件传递的未被 props 申明的变量都会在子组件的$attrs 中 所有监听事件都在 $listeners 中

```javascript
// 父组件

<template>
  <div>
    <div>AttrsListeners</div>
    <AttrsChildren
      :title="title"
      :bar="bar"
      :foo="foo"
      @test="test"
      baz="2312"
    ></AttrsChildren>
  </div>
</template>


// 子组件 AttrsChildren
<template>
  <div class="list">
    <div class="item">
      <div class="title">child1</div>
      <div>title: {{ title }}</div>
      <div>attrs属性：{{ $attrs }}</div>
      <div>listeners监听事件： {{ $listeners }}</div>
      /* 可以通过此方法将$attrs再次传入子组件中 */
      <AttrsChildren2 v-bind="$attrs" v-on="$listeners"></AttrsChildren2>
    </div>
  </div>
</template>

export default {
  data() {
    return {};
  },
  props: {
    title: String
  },
  // inheritAttrs true 将
  inheritAttrs: false,
  components: {
    AttrsChildren2
  },
  created() {
    // 未在 props中定义的变量 都在$attrs中
    // $attrs { bar: "bar", foo: "foo", baz: "2312"}
    // 可以通过此方法将$attrs再次传入子组件中

    // 所有监听事件 都在 $listeners中
    console.log(this.$listeners, this.$attrs);
  }
};


```

#### 7 Slot 插槽

```javascript
// 父组件
<template>
  <div>
    <div>Slot</div>
    <SlotChild1>
      <template v-slot:default="slotProps">
        <div class="un">默认插槽 {{ slotProps }}</div>
      </template>
      <template v-slot:slot1>
        <div class="name-slot">具名插槽</div>
      </template>
    </SlotChild1>
  </div>
</template>

//子组件 SlotChild1
<template>
  <div>
    <div>Slot1</div>
    <slot v-bind:user="user1">默认内容</slot>
    <slot name="slot1"></slot>
  </div>
</template>
  data() {
    return {
      user1: {
        foo: "foo",
        bar: "bar"
      }
    };
  },
```

### Vue React 区别

### Vue 计算属性

#### 计算属性和方法

1. 主要区别计算属性 可以缓存 ，method 不能
2. 一般情况下计算属性不能传参，但可以通过闭包来传参

```javascript
  <div :data="func(a,b,c)"> </div>
  data() {
    return {
      a: 1,
      b: 2,
      c: 3
    }
  },

  computed: {
    func(){
      return func(a,b,c){
        return a + b + c
      }
    }
  }

```

## JavaScript

### JS 防抖和节流

```javascript
// 防抖
// 多由于输入框或按钮 防止多次重复点击 导致接口等多次请求

function debounce(func, wait) {
  let timer = null;
  let _this = this;
  return function (...args) {
    clearTimeout(timer);
    timer = setTimeout(function () {
      func.apply(_this, args);
    }, wait);
  };
}

// 节流
// 多用于持续开销的方法或函数 比如滑动 减小性能消耗
function throttle(func, wait) {
  let timer = null;
  let _this = this;
  return function (...args) {
    if (!timer) {
      setTimeout(function () {
        func.apply(_this, args);
        timer = null;
      }, wait);
    }
  };
}
```

### 原型与原型链

```javascript
// 例1
function Person(name, age) {
  this.name = name || "default";
  this.age = age || 18;
}

Person.prototype.say = function () {
  console.log("hi");
};

var person = new Person("jack", 22);
```

#### 1. 原型对象 即 Person.prototype

> 在 JavaScript 中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个 prototype 属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。

```javascript
Person.prototype.say = function () {
  console.log("hi");
};
// 原型对象 Person.prototype 只是一个普通对象
// 在默认情况下，所有的原型对象都会自动获得一个 constructor（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数（Person）
person.constructor = Person;
// person 是Person 函数的实例
Person.prototype.constructor === Person;
// 所有Person.prototype 也是 Person的实例

// 可以理解为在函数创建的时候 创建了一个Person的实例 并把实例赋值给了 Person.prototype
var a = new Person();
Person.prototype = A;
```

#### 2. 原型链 \_\_proto\_\_

> 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到 Object 对象的原型，Object 对象的原型没有原型，如果在 Object 原型中依然没有找到，则返回 undefined。

> Object 是 JS 中所有对象数据类型的基类(最顶层的类)在 Object.prototype 上**proto** 为 NULL。

```javascript
Person.prototype.constructor == Person;
// 原型链指向的不是构造函数 而是构造函数的原型对象
// new 操作符做的也就是这个操作
person.__proto__ == Person.prototype;
person.constructor == Person;

// 例子
person.__proto__ === Person.prototype; // 指向的是person的构造函数的原型对象

Person.__proto__ === Function.prototype; // Person 由Function申明

Person.prototype.__proto__ === Object.prototype; // Person.protytype是一个普通对象 对象的构造函数原型是Object.prototype

Object.__proto__ === Function.prototype; // Object由Function构造  typeof Object  === 'function';

Object.prototype.__proto__ === null; // null 处于原型链的顶层
```

#### 3.函数对象

```javascript
Number.__proto__ === Function.prototype; // true
Number.constructor == Function; //true

Boolean.__proto__ === Function.prototype; // true
Boolean.constructor == Function; //true

String.__proto__ === Function.prototype; // true
String.constructor == Function; //true

// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身
Object.__proto__ === Function.prototype; // true
Object.constructor == Function; // true

// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身
Function.__proto__ === Function.prototype; // true
Function.constructor == Function; //true

Array.__proto__ === Function.prototype; // true
Array.constructor == Function; //true

RegExp.__proto__ === Function.prototype; // true
RegExp.constructor == Function; //true

Error.__proto__ === Function.prototype; // true
Error.constructor == Function; //true

Date.__proto__ === Function.prototype; // true
Date.constructor == Function; //true

// JavaScript中有内置(build-in)构造器/对象共计12个（ES5中新加了JSON），这里列举了可访问的8个构造器。剩下如Global不能直接访问，Arguments仅在函数调用时由JS引擎创建，Math，JSON是以对象形式存在的，无需new。它们的proto是Object.prototype

Math.__proto__ === Object.prototype; // true
Math.construrctor == Object; // true

JSON.__proto__ === Object.prototype; // true
JSON.construrctor == Object; //true

// 所有的构造器都来自于 Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了·Function.prototype·的属性及方法。如length、call、apply、bind
// 而 Function.prototype 为空函数 （Empty function）

console.log(typeof Function.prototype); // function
console.log(typeof Object.prototype); // object
console.log(typeof Number.prototype); // object
console.log(typeof Boolean.prototype); // object
console.log(typeof String.prototype); // object
console.log(typeof Array.prototype); // object
console.log(typeof RegExp.prototype); // object
console.log(typeof Error.prototype); // object
console.log(typeof Date.prototype); // object
console.log(typeof Object.prototype); // object

Function.prototype.__proto__ === Object.prototype; // true

// 说明函数的原型链指向的都是普通对象
// 这说明所有的构造器也都是一个普通 JS 对象，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等
```

```javascript
function Person(name, age) {
  this.name = name || "default";
  this.age = age || 18;
}

Person.prototype.say = function () {
  console.log("hi");
};

var person = new Person("jack", 22);

person.__proto__ === Person.prototype; // true;
person.__proto__ === person.constructor.prototype; // true

// 重写 Person.prototype
function Person(name, age) {
  this.name = name || "default";
  this.age = age || 18;
}

Person.prototype = {
  say: function () {},
};

var person = new Person("jack", 22);
person.__proto__ === Person.prototype; // true;
person.__proto__ === person.constructor.prototype; // false

// 因为重写了 Person.prototype  perosn.constructor === Object
// 而 Object.prototype === {}.__proto__
```

[参考链接](https://www.jianshu.com/p/a4e1e7b6f4f8)

### 深拷贝

#### 1. 转换为 JSON

```javascript
JSON.parse(JSON.stringfy(obj));
```

#### 2. 手写递归

```javascript
function deepClone(object) {
  let obj;
  if (object && typeof object === "object") {
    if (toString.call(object) === "[object Object]") {
      obj = {};
      for (let i in object) {
        obj[i] = deepClone(object[i]);
      }
    } else if (object.constructor === Array) {
      obj = [];
      for (let item of object) {
        obj.push(deepClone(item));
      }
    } else {
      return object;
    }
  } else {
    return object;
  }
  return obj;
}
```
