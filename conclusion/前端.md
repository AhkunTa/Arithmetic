## Vue

### Vue 中双向数据绑定的实现原理

```javascript
// vue 双向绑定原理
// 实现一个双向绑定
function observe(data) {
  if (!data || typeof data !== "object") {
    return;
  }
  Object.keys(data).forEach((key, index) => {
    defineReactive(data, key, data[key]);
  });
}
function defineReactive(data, key, value) {
  // 获取递归获取子属性
  observe(value);
  let dep = new Dep();
  // 主要使用 defineProperty方法
  Object.defineProperty(data, key, {
    set: function (newVal) {
      if (value == newVal) {
        return;
      }
      console.log("set " + newVal);
      value = newVal;
      dep.notify();
    },
    get: function () {
      if (Dep.target) {
        dep.add(Dep.target);
      }
      return value;
    },
  });
}

function Dep() {
  this.subs = [];
}
Dep.prototype.add = function (sub) {
  this.subs.push(sub);
};

Dep.prototype.notify = function () {
  this.subs.forEach(sub => {
    console.log(sub);
    sub.update();
  });
};
Dep.target = null;
function Wacther(vm, prop, callback) {
  this.vm = vm;
  this.prop = prop;
  this.value = this.get();
  this.callback = callback;
}

// 观察器
Wacther.prototype = {
  update: function (val) {
    let oldVal = this.value;
    let value = this.vm.$data[this.prop];

    if (oldVal !== value) {
      this.value = value;
      this.callback(value);
    }
  },
  get: function () {
    Dep.target = this;
    let value = this.vm.$data[this.prop];
    Dep.target = null;
    return value;
  },
};

function Vue(options, prop) {
  this.$data = options.data;
  this.prop = prop;
  this.$el = document.querySelector(options.el);
  this.init();
}

Vue.prototype.init = function () {
  observe(this.$data);
  console.log(this.$data);
  this.$el.textContent = this.$data.name;

  new Wacther(this, this.prop, value => {
    this.$el.textContent = value;
  });
};

var vm = new Vue(
  {
    el: "#link",
    data: {
      name: "123456",
    },
  },
  "name"
);
```

### Vue 的生命周期

1. beforeCreate
   > 创建前 此时刚刚实例化完 Vue 事件监听 和 数据观测之前
2. created
   > 创建后 此时 完成了事件监听 和数据观测 通常用于数据初始化 在页面 created 是请求后端接口
3. beforeMount
   > 挂载前 在模板挂载之前 此时还无法操作 dom
4. mounted
   > 挂载后 此时模板 template 已经渲染完成即模板渲染成 html 在此之后可以操作 dom 节点
5. beforeUpdate
   > 更新前 发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器
6. updated
   > 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子
7. activated
   > 被 keep-alive 缓存的组件激活时调用
8. deactivated
   > 被 keep-alive 缓存的组件停用时调用
9. beforeDestroy
   > 实例销毁前 在这一步，实例仍然完全可用
10. destroyed
    > 实例销毁后 该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁
11. errorCaptured 2.5.0+
    > 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播

### Vue 组件间通信

#### 1 Provide Inject 双向绑定

```javascript
   // 父组件
  data(){
    return {
      // 父组件必须为对象等引用类型 数据将会双向绑定
      // 基础数据类型 不会双向绑定
      // 如 testData: '测试数据...'
      testData: {
        test: '测试数据...'
      }
    }
  },
  provide() {
    return {
      provideTest: this.testData,
    };
  },

  // 子组件 接收方式
  // 1
  inject: ["provideTest"],
  // 2
  inject: {
    provideTest: {
      default: "default"
    }
  },

```

#### 2 Vue.observable 双向绑定

> vue.observable 仅在 2.6 版本及以上

```javascript
// 增加 store.js文件
import Vue from "vue";
let store = Vue.observable({
  name: "111",
  age: 28,
});

let mutations = {
  addAge: function (count) {
    store.age += count;
  },
  changeName: function (name) {
    store.name = name;
  },
};
export { store, mutations };

// 在组件中引入即可 类似VUEX文件引入
```

#### 3 $props $emit

> 父组件通过 props 传递数据 子组件通过事件 $emit 来接受事件和参数

**props 数据双向绑定**

#### 4 VUEX

```javascript

```

#### 5 Bus 文件

> 和 2 类似

```javascript
// bus.js
import Vue from "vue";

export default new Vue();
// 在子组件中 通过 $on来监听
```

#### 6 $attrs $listeners 文件

> 使用方法类似 $emit 和 props

> 所有父组件传递的未被 props 申明的变量都会在子组件的$attrs 中 所有监听事件都在 $listeners 中

```javascript
// 父组件

<template>
  <div>
    <div>AttrsListeners</div>
    <AttrsChildren
      :title="title"
      :bar="bar"
      :foo="foo"
      @test="test"
      baz="2312"
    ></AttrsChildren>
  </div>
</template>


// 子组件 AttrsChildren
<template>
  <div class="list">
    <div class="item">
      <div class="title">child1</div>
      <div>title: {{ title }}</div>
      <div>attrs属性：{{ $attrs }}</div>
      <div>listeners监听事件： {{ $listeners }}</div>
      /* 可以通过此方法将$attrs再次传入子组件中 */
      <AttrsChildren2 v-bind="$attrs" v-on="$listeners"></AttrsChildren2>
    </div>
  </div>
</template>

export default {
  data() {
    return {};
  },
  props: {
    title: String
  },
  // inheritAttrs true 将
  inheritAttrs: false,
  components: {
    AttrsChildren2
  },
  created() {
    // 未在 props中定义的变量 都在$attrs中
    // $attrs { bar: "bar", foo: "foo", baz: "2312"}
    // 可以通过此方法将$attrs再次传入子组件中

    // 所有监听事件 都在 $listeners中
    console.log(this.$listeners, this.$attrs);
  }
};


```

#### 7 Slot 插槽

```javascript
// 父组件
<template>
  <div>
    <div>Slot</div>
    <SlotChild1>
      <template v-slot:default="slotProps">
        <div class="un">默认插槽 {{ slotProps }}</div>
      </template>
      <template v-slot:slot1>
        <div class="name-slot">具名插槽</div>
      </template>
    </SlotChild1>
  </div>
</template>

//子组件 SlotChild1
<template>
  <div>
    <div>Slot1</div>
    <slot v-bind:user="user1">默认内容</slot>
    <slot name="slot1"></slot>
  </div>
</template>
  data() {
    return {
      user1: {
        foo: "foo",
        bar: "bar"
      }
    };
  },
```

### Vue React 区别

### Vue 计算属性

#### 计算属性和方法

1. 主要区别计算属性 可以缓存 ，method 不能
2. 一般情况下计算属性不能传参，但可以通过闭包来传参

```javascript
  <div :data="func(a,b,c)"> </div>
  data() {
    return {
      a: 1,
      b: 2,
      c: 3
    }
  },

  computed: {
    func(){
      return func(a,b,c){
        return a + b + c
      }
    }
  }

```

## JavaScript

### JS 防抖和节流

```javascript
// 防抖
// 多由于输入框或按钮 防止多次重复点击 导致接口等多次请求

function debounce(func, wait) {
  let timer = null;
  let _this = this;
  return function (...args) {
    clearTimeout(timer);
    timer = setTimeout(function () {
      func.apply(_this, args);
    }, wait);
  };
}

// 节流
// 多用于持续开销的方法或函数 比如滑动 减小性能消耗
function throttle(func, wait) {
  let timer = null;
  let _this = this;
  return function (...args) {
    if (!timer) {
      setTimeout(function () {
        func.apply(_this, args);
        timer = null;
      }, wait);
    }
  };
}
```
