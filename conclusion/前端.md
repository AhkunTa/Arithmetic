## Vue

### Vue 中双向数据绑定的实现原理

```javascript
// vue 双向绑定原理
// 实现一个双向绑定
function observe(data) {
  if (!data || typeof data !== "object") {
    return;
  }
  Object.keys(data).forEach((key, index) => {
    defineReactive(data, key, data[key]);
  });
}
function defineReactive(data, key, value) {
  // 获取递归获取子属性
  observe(value);
  let dep = new Dep();
  // 主要使用 defineProperty方法
  Object.defineProperty(data, key, {
    set: function (newVal) {
      if (value == newVal) {
        return;
      }
      console.log("set " + newVal);
      value = newVal;
      dep.notify();
    },
    get: function () {
      if (Dep.target) {
        dep.add(Dep.target);
      }
      return value;
    },
  });
}

function Dep() {
  this.subs = [];
}
Dep.prototype.add = function (sub) {
  this.subs.push(sub);
};

Dep.prototype.notify = function () {
  this.subs.forEach(sub => {
    console.log(sub);
    sub.update();
  });
};
Dep.target = null;

function Wacther(vm, prop, callback) {
  this.vm = vm;
  this.prop = prop;
  this.value = this.get();
  this.callback = callback;
}

// 观察器
Wacther.prototype = {
  update: function (val) {
    let oldVal = this.value;
    let value = this.vm.$data[this.prop];

    if (oldVal !== value) {
      this.value = value;
      this.callback(value);
    }
  },
  get: function () {
    Dep.target = this;
    let value = this.vm.$data[this.prop];
    Dep.target = null;
    return value;
  },
};

function Vue(options, prop) {
  this.$data = options.data;
  this.prop = prop;
  this.$el = document.querySelector(options.el);
  this.init();
}

Vue.prototype.init = function () {
  observe(this.$data);
  console.log(this.$data);
  this.$el.textContent = this.$data.name;

  new Wacther(this, this.prop, value => {
    this.$el.textContent = value;
  });
};

var vm = new Vue(
  {
    el: "#link",
    data: {
      name: "123456",
    },
  },
  "name"
);
```

### Vue 的生命周期

1. beforeCreate
   > 创建前 此时刚刚实例化完 Vue 事件监听 和 数据观测之前
2. created
   > 创建后 此时 完成了事件监听 和数据观测 通常用于数据初始化 在页面 created 是请求后端接口
3. beforeMount
   > 挂载前 在模板挂载之前 此时还无法操作 dom
4. mounted
   > 挂载后 此时模板 template 已经渲染完成即模板渲染成 html 在此之后可以操作 dom 节点
5. beforeUpdate
   > 更新前 发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器
6. updated
   > 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子
7. activated
   > 被 keep-alive 缓存的组件激活时调用
8. deactivated
   > 被 keep-alive 缓存的组件停用时调用
9. beforeDestroy
   > 实例销毁前 在这一步，实例仍然完全可用
10. destroyed
    > 实例销毁后 该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁
11. errorCaptured 2.5.0+
    > 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播

### Vue 组件间通信

#### 1 Provide Inject 双向绑定

```javascript
   // 父组件
  data(){
    return {
      // 父组件必须为对象等引用类型 数据将会双向绑定
      // 基础数据类型 不会双向绑定
      // 如 testData: '测试数据...'
      testData: {
        test: '测试数据...'
      }
    }
  },
  provide() {
    return {
      provideTest: this.testData,
    };
  },

  // 子组件 接收方式
  // 1
  inject: ["provideTest"],
  // 2
  inject: {
    provideTest: {
      default: "default"
    }
  },

```

#### 2 Vue.observable 双向绑定

> vue.observable 仅在 2.6 版本及以上

```javascript
// 增加 store.js文件
import Vue from "vue";
let store = Vue.observable({
  name: "111",
  age: 28,
});

let mutations = {
  addAge: function (count) {
    store.age += count;
  },
  changeName: function (name) {
    store.name = name;
  },
};
export { store, mutations };

// 在组件中引入即可 类似VUEX文件引入
```

#### 3 $props $emit

> 父组件通过 props 传递数据 子组件通过事件 $emit 来接受事件和参数

**props 数据双向绑定**

#### 4 VUEX

```javascript

```

#### 5 Bus 文件

> 和 2 类似

```javascript
// bus.js
import Vue from "vue";

export default new Vue();
// 在子组件中 通过 $on来监听
```

#### 6 $attrs $listeners 文件

> 使用方法类似 $emit 和 props

> 所有父组件传递的未被 props 申明的变量都会在子组件的$attrs 中 所有监听事件都在 $listeners 中

```javascript
// 父组件

<template>
  <div>
    <div>AttrsListeners</div>
    <AttrsChildren
      :title="title"
      :bar="bar"
      :foo="foo"
      @test="test"
      baz="2312"
    ></AttrsChildren>
  </div>
</template>


// 子组件 AttrsChildren
<template>
  <div class="list">
    <div class="item">
      <div class="title">child1</div>
      <div>title: {{ title }}</div>
      <div>attrs属性：{{ $attrs }}</div>
      <div>listeners监听事件： {{ $listeners }}</div>
      /* 可以通过此方法将$attrs再次传入子组件中 */
      <AttrsChildren2 v-bind="$attrs" v-on="$listeners"></AttrsChildren2>
    </div>
  </div>
</template>

export default {
  data() {
    return {};
  },
  props: {
    title: String
  },
  // inheritAttrs true 将
  inheritAttrs: false,
  components: {
    AttrsChildren2
  },
  created() {
    // 未在 props中定义的变量 都在$attrs中
    // $attrs { bar: "bar", foo: "foo", baz: "2312"}
    // 可以通过此方法将$attrs再次传入子组件中

    // 所有监听事件 都在 $listeners中
    console.log(this.$listeners, this.$attrs);
  }
};


```

#### 7 Slot 插槽

```javascript
// 父组件
<template>
  <div>
    <div>Slot</div>
    <SlotChild1>
      <template v-slot:default="slotProps">
        <div class="un">默认插槽 {{ slotProps }}</div>
      </template>
      <template v-slot:slot1>
        <div class="name-slot">具名插槽</div>
      </template>
    </SlotChild1>
  </div>
</template>

//子组件 SlotChild1
<template>
  <div>
    <div>Slot1</div>
    <slot v-bind:user="user1">默认内容</slot>
    <slot name="slot1"></slot>
  </div>
</template>
  data() {
    return {
      user1: {
        foo: "foo",
        bar: "bar"
      }
    };
  },
```

### Vue React 区别

### Vue 计算属性

#### 计算属性和方法

1. 主要区别计算属性 可以缓存 ，method 不能
2. 一般情况下计算属性不能传参，但可以通过闭包来传参

```javascript
  <div :data="func(a,b,c)"> </div>
  data() {
    return {
      a: 1,
      b: 2,
      c: 3
    }
  },

  computed: {
    func(){
      return func(a,b,c){
        return a + b + c
      }
    }
  }

```

### Vue 内部闭包 cached 方法

```javascript
// 使用闭包缓存住cache中的值
// 若已存在直接返回 若不存在返回方法调用的值 并且赋值给cache以供下次判断
function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
// vue中利用此函数的方法 都利用了cached函数缓存了所有判断过的值
// 此方法将连接符-转化为驼峰法
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : "";
  });
});

// 将首字母变成大写
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
```

### Vue 内部任务延迟实现

> V 2.6.12 中先使用 Promise -> MutationObserver -> setImmediate -> setTimeout

> V 2.5.16
> 宏任务： macroTimerFunc = setImmediate -> MessageChannel -> setTimeout  
> 微任务： microTimerFunc = Promise 如 Promise 不存在 返回宏任务

#### 在 2.6 中 VUE 主要使用的是微任务触发 而在 2.5 中使用宏任务和微任务结合使用

---

### Vue 手动设置的 get set

> 主要通过 defineReactive 方法 里 Object.getOwnPropertyDescriptor 判断对象上是否有 set 或者 get 如果有值 那就直接返回设置的 set 和 get

```javascript
// 如果 a属性下有get和set 就会覆盖原来的get 和set
computed: {
  a: {
    get(){

    },
    set() {

    }
  }
}

```

```javascript
/**
 * Define a reactive property on an Object.
 * 在对象上定义一个无功属性。
 * 更新数据
 * 通过defineProperty的set方法去通知notify()订阅者subscribers有新的值修改
 * 添加观察者 get set方法
 */
function defineReactive(
  obj, //对象
  key, //对象的key
  val, //监听的数据 返回的数据
  customSetter, //  日志函数
  shallow //是否要添加__ob__ 属性
) {
  //实例化一个主题对象，对象中有空的观察者列表
  var dep = new Dep();
  //获取描述属性
  var property = Object.getOwnPropertyDescriptor(obj, key);
  var _property = Object.getOwnPropertyNames(obj); //获取实力对象属性或者方法，包括定义的描述属性

  if (property && property.configurable === false) {
    return;
  }
  var getter = property && property.get;

  if (!getter && arguments.length === 2) {
    val = obj[key];
  }
  var setter = property && property.set;
  //判断value 是否有__ob__    实例化 dep对象,获取dep对象  为 value添加__ob__ 属性递归把val添加到观察者中  返回 new Observer 实例化的对象
  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        //Dep.target 静态标志 标志了Dep添加了Watcher 实例化的对象
        //添加一个dep
        dep.depend();
        if (childOb) {
          //如果子节点存在也添加一个dep
          childOb.dep.depend();
          if (Array.isArray(value)) {
            //判断是否是数组 如果是数组
            dependArray(value); //则数组也添加dep
          }
        }
      }
      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return;
      }
      if ("development" !== "production" && customSetter) {
        customSetter();
      }
      if (setter) {
        // property = Object.getOwnPropertyDescriptor(obj, key);
        // setter = property && property.set;
        setter.call(obj, newVal);
      } else {
        //新的值直接给他
        val = newVal;
      }
      //observe 添加 观察者
      childOb = !shallow && observe(newVal);
      //更新数据
      dep.notify();
    },
  });
}
```

### Vue provide Inject

> Vue 中主要使用 initInjections(vm) initProvide(vm) 这两个方法来初始化 provide inject

```javascript
// 1. 首先执行initInjections 主要获取 inject属性值, 获取后循环$parent属性 如果存在_provide属性则跳出直接赋值 如果没有_provide属性 则再取$parent属性直到最外层 (最外层vm的$parent为undefined) 然后获取其默认的default属性

// 首先会进行 normalizeInject 方法调用
//  将
// inject: {
//         aaa: {
//           default: 123
//         },
//         bbb: {
//           default: 2323
//         }
//  }

// 转化为
// {
//     "aaa": {
//         "from": "aaa",
//         "default": 123
//     },
//     "bbb": {
//         "from": "bbb",
//         "default": 2323
//     }
// }
// 核心代码
var provideKey = inject[key].from; // 获取key的值
var source = vm;
while (source) {
  if (source._provided && hasOwn(source._provided, provideKey)) {
    //判断_provided 存在么 并且是对象的时候，并且实例化属性provideKey 存在
    result[key] = source._provided[provideKey]; //获取值 存起来
    break;
  }
  source = source.$parent; //循环父节点
}
if (!source) {
  //如果vm 不存在
  if ("default" in inject[key]) {
    // 判断default key存在inject[key]中么
    var provideDefault = inject[key].default; //如果存在则获取默认default的值
    result[key] =
      typeof provideDefault === "function" //如果是函数则执行
        ? provideDefault.call(vm)
        : provideDefault;
  } else {
    warn('Injection "' + key + '" not found', vm);
  }
}

//  initProvide(vm) 就是直接判断有没有provide属性 有则给其vm赋值_provide
function initProvide(vm) {
  var provide = vm.$options.provide; //provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。
  if (provide) {
    //判断provide 存在么
    vm._provided =
      typeof provide === "function" //判断是否是函数如果是函数则执行
        ? provide.call(vm)
        : provide;
  }
}
```

### Vue $orceUpdated

> 直接调用的\_watcher 监听器的 update 方法 update 方法执行 watcher.prototype.run

## JavaScript

### JS 防抖和节流

```javascript
// 防抖
// 多由于输入框或按钮 防止多次重复点击 导致接口等多次请求

function debounce(func, wait) {
  let timer = null;
  let _this = this;
  return function (...args) {
    clearTimeout(timer);
    timer = setTimeout(function () {
      func.apply(_this, args);
    }, wait);
  };
}

// 节流
// 多用于持续开销的方法或函数 比如滑动 减小性能消耗
function throttle(func, wait) {
  let timer = null;
  let _this = this;
  return function (...args) {
    if (!timer) {
      setTimeout(function () {
        func.apply(_this, args);
        timer = null;
      }, wait);
    }
  };
}
```

### 原型与原型链

```javascript
// 例1
function Person(name, age) {
  this.name = name || "default";
  this.age = age || 18;
}

Person.prototype.say = function () {
  console.log("hi");
};

var person = new Person("jack", 22);
```

#### 1. 原型对象 即 Person.prototype

> 在 JavaScript 中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个 prototype 属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。

```javascript
Person.prototype.say = function () {
  console.log("hi");
};
// 原型对象 Person.prototype 只是一个普通对象
// 在默认情况下，所有的原型对象都会自动获得一个 constructor（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数（Person）
person.constructor = Person;
// person 是Person 函数的实例
Person.prototype.constructor === Person;
// 所有Person.prototype 也是 Person的实例

// 可以理解为在函数创建的时候 创建了一个Person的实例 并把实例赋值给了 Person.prototype
var a = new Person();
Person.prototype = A;
```

#### 2. 原型链 \_\_proto\_\_

> 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到 Object 对象的原型，Object 对象的原型没有原型，如果在 Object 原型中依然没有找到，则返回 undefined。

> Object 是 JS 中所有对象数据类型的基类(最顶层的类)在 Object.prototype 上**proto** 为 NULL。

```javascript
Person.prototype.constructor == Person;
// 原型链指向的不是构造函数 而是构造函数的原型对象
// new 操作符做的也就是这个操作
person.__proto__ === Person.prototype;
person.constructor === Person;

// 例子
person.__proto__ === Person.prototype; // 指向的是person的构造函数的原型对象

Person.__proto__ === Function.prototype; // Person 由Function申明

Person.prototype.__proto__ === Object.prototype; // Person.protytype是一个普通对象 对象的构造函数原型是Object.prototype

Object.__proto__ === Function.prototype; // Object由Function构造  typeof Object  === 'function';

Object.prototype.__proto__ === null; // null 处于原型链的顶层
```

#### 3.函数对象

```javascript
Number.__proto__ === Function.prototype; // true
Number.constructor === Function; //true

Boolean.__proto__ === Function.prototype; // true
Boolean.constructor === Function; //true

String.__proto__ === Function.prototype; // true
String.constructor === Function; //true

// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身
Object.__proto__ === Function.prototype; // true
Object.constructor === Function; // true

// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身
Function.__proto__ === Function.prototype; // true
Function.constructor === Function; //true

Array.__proto__ === Function.prototype; // true
Array.constructor === Function; //true

RegExp.__proto__ === Function.prototype; // true
RegExp.constructor === Function; //true

Error.__proto__ === Function.prototype; // true
Error.constructor === Function; //true

Date.__proto__ === Function.prototype; // true
Date.constructor === Function; //true

// JavaScript中有内置(build-in)构造器/对象共计12个（ES5中新加了JSON），这里列举了可访问的8个构造器。剩下如Global不能直接访问，Arguments仅在函数调用时由JS引擎创建，Math，JSON是以对象形式存在的，无需new。它们的proto是Object.prototype

Math.__proto__ === Object.prototype; // true
Math.construrctor === Object; // true

JSON.__proto__ === Object.prototype; // true
JSON.construrctor === Object; //true

// 所有的构造器都来自于 Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了·Function.prototype·的属性及方法。如length、call、apply、bind
// 而 Function.prototype 为空函数 （Empty function）

console.log(typeof Function.prototype); // function
console.log(typeof Object.prototype); // object
console.log(typeof Number.prototype); // object
console.log(typeof Boolean.prototype); // object
console.log(typeof String.prototype); // object
console.log(typeof Array.prototype); // object
console.log(typeof RegExp.prototype); // object
console.log(typeof Error.prototype); // object
console.log(typeof Date.prototype); // object
console.log(typeof Object.prototype); // object

Function.prototype.__proto__ === Object.prototype; // true

// 说明函数的原型链指向的都是普通对象
// 这说明所有的构造器也都是一个普通 JS 对象，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等
```

```javascript
function Person(name, age) {
  this.name = name || "default";
  this.age = age || 18;
}

Person.prototype.say = function () {
  console.log("hi");
};

var person = new Person("jack", 22);

person.__proto__ === Person.prototype; // true;
person.__proto__ === person.constructor.prototype; // true

// 重写 Person.prototype
function Person(name, age) {
  this.name = name || "default";
  this.age = age || 18;
}

Person.prototype = {
  say: function () {},
};

var person = new Person("jack", 22);
person.__proto__ === Person.prototype; // true;
person.__proto__ === person.constructor.prototype; // false

// 因为重写了 Person.prototype  perosn.constructor === Object
// 而 Object.prototype === {}.__proto__
```

[参考链接](https://www.jianshu.com/p/a4e1e7b6f4f8)

### 深拷贝

#### 1. 转换为 JSON

```javascript
JSON.parse(JSON.stringfy(obj));
```

#### 2. 手写递归

```javascript
function deepClone(object) {
  let obj;
  if (object && typeof object === "object") {
    if (toString.call(object) === "[object Object]") {
      obj = {};
      for (let i in object) {
        obj[i] = deepClone(object[i]);
      }
    } else if (object.constructor === Array) {
      obj = [];
      for (let item of object) {
        obj.push(deepClone(item));
      }
    } else {
      return object;
    }
  } else {
    return object;
  }
  return obj;
}
```

#### 3. Object.assign()

> Object.assign 内部也是浅拷贝 只能深拷贝一层

### Array.prototype.slice.call(aruments) 原理

1. arguments 定义

> arguments 是一个对应于传递给函数的参数的类数组对象。 在所有函数中（非箭头函数）都有这个对象

```javascript
typeof arguments === "object";
Object.prototype.toString.call(argumnets) === "[object Arguments]";
```

2. Array.prototype.slice.call()

> Array.prototype.slice.call(aruments) 可以将 arguments 转化为数组类型

```javascript
// slice 源码 大致实现

Array.prototype.mySlice = function (start, end) {
  // Array.prototype.slice.call(aruments) 修改了slice里的this指向
  var result = [];

  var begin = start || 0;
  var len = this.length;
  // behin 远小于 0   begin + len < 0  直接返回 0
  // 否则 从后往前倒数
  begin = begin >= 0 ? begin : Math.max(0, begin + len);
  var tail = typeof end == "number" ? Math.min(end, len) : len;
  if (tail < 0) {
    tail = tail + len;
  }
  var length = tail - begin;

  for (var i = 0; i < length; i++) {
    result.push(this[begin + i]);
  }

  return result;
};
```

---

### call apply 原理实现

1. 使用原生方法

```javascript
Function.prototype._call2 = function (...args /* 也可以使用args*/) {
  console.log("call2=====");
  var obj = arguments[0];
  // 若函数有返回值需返回
  return this.apply(obj, [...arguments].slice(1));
};

Function.prototype._apply2 = function (...args /* 也可以使用args*/) {
  console.log("apply2=====");
  var obj = arguments[0];
  var arg1 = arguments[1];
  // 防止不传第二个参数 ...arg1报错
  if (!arg1) {
    arg1 = [];
  }
  // 若函数有返回值需返回
  return this.call(obj, ...arg1);
};
```

2. 不使用原生方法

```javascript
// 当_call _apply 不传参的时候 ...arg 不是可迭代对象会报错
// ...args 和 arguments 几乎相等 不过arguments需要转化为数组对象
Function.prototype._call = function (...args) {
  console.log("call1=====");
  var obj = args[0] || window;
  obj.tempFn = this;
  var result = obj.tempFn(...[...args].slice(1));
  delete obj.tempFn;
  return result;
};

Function.prototype._apply = function (...args) {
  console.log("apply1=====");
  var obj = args[0] || window;
  obj.tempFn = this;
  // 兼容不传参处理
  var arg = args[1];
  if (!arg) {
    arg = [];
  }
  var result = obj.tempFn(...arg);
  delete obj.tempFn;
  return result;
};
```

3. 不使用原生方法 && 扩展运算符...

```javascript
// 不使用扩展运算符 只能取 arguments对象
Function.prototype._call3 = function () {
  // 完善 若arguments[0] 为基础数据对象

  var obj = new Object(arguments[0]) || window;
  var arg2 = [];
  for (var i = 1; i < arguments.length; i++) {
    arg2.push("arguments[" + i + "]");
  }
  obj.tempFn = this;
  // 使用eval 隐式转换
  var result = eval("obj.tempFn(" + arg2 + ")");
  delete obj.tempFn;
  return result;
};

Function.prototype._apply3 = function () {
  var obj = new Object(arguments[0]) || window;
  var arg2 = [];
  obj.tempFn = this;
  // if (arguments[1]) {
  //   for (var i = 0; i < arguments[1].length; i++) {
  //     arg2.push("arguments[1][" + i + "]");
  //   }
  // }
  // var result = eval("obj.tempFn(" + arg2 + ")");
  var result = eval("obj.tempFn(" + arguments[1] + ")");
  delete obj.tempFn;
  return result;
};
```

## css

### BFC

> BFC(Block Formatting Context)块级格式化上下文，是用于布局块级盒子的一块渲染区域。MDN 上的解释：BFC 是 Web 页面 CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。

> 一个 BFC 的范围包含创建该上下文元素的所有子元素，但不包括创建了新 BFC 的子元素的内部元素。这从另一方角度说明，一个元素不能同时存在于两个 BFC 中。因为如果一个元素能够同时处于两个 BFC 中，那么就意味着这个元素能与两个 BFC 中的元素发生作用，就违反了 BFC 的隔离作用。

#### BFC 触发方式

1. 根元素，即 HTML 标签
2. 浮动元素：float 值为 left、right
3. overflow 值不为 visible，为 auto、scroll、hidden
4. display 值为 inline-block、table-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid
5. 定位元素：position 值为 absolute、fixed

> 注意：display:table 也可以生成 BFC 的原因在于 Table 会默认生成一个匿名的 table-cell，是这个匿名的 table-cell 生成了 BFC。

#### 浏览器对 BFC 区域的约束规则

1. 内部的 Box 会在垂直方向上一个接一个的放置
2. 内部的 Box 垂直方向上的距离由 margin 决定。（完整的说法是：属于同一个 BFC 的两个相邻 Box 的 margin 会发生折叠，不同 BFC 不会发生折叠。）
3. 每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明 BFC 中子元素不会超出他的包含块，而 position 为 absolute 的元素可以超出他的包含块边界）
4. BFC 的区域不会与 float 的元素区域重叠
5. 计算 BFC 的高度时，浮动子元素也参与计算
