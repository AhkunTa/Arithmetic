## Vue

### Vue 初始化

```javascript
// 初始化两种方式
// el 绑定 或者 $mount 绑定

new Vue({
  el: "#app",
});
// 或
new Vue({}).$mount("#app");
// 两者没有区别
// 应为 new Vue()时
function Vue(options) {
  this._init(options);
}
initMixin(Vue); //初始化vue
function initMixin(Vue) {
  Vue.prototype._init = function(options) {
    ...
    // 主要代码
    if (vm.$options.el) {
      // Vue 的$mount()为手动挂载，
      // 在项目中可用于延时挂载（例如在挂载之前要进行一些其他操作、判断等），之后要手动挂载上。
      // new Vue时，el和$mount并没有本质上的不同。
      vm.$mount(vm.$options.el);
    }
  };
}

// 主要还是$mount这个方法  $mount 有两个方法 后续会覆盖初始化的方法
// $mount 执行 mountComponent
Vue.prototype.$mount = function(
  el, //真实dom 或者是string
  hydrating //新的虚拟dom vonde
) {
  // debugger
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
};

 function mountComponent(
    vm, //vnode
    el, //dom
    hydrating
  ) {
    vm.$el = el; //dom
    console.log("options.render =============", vm.$options.render);

    //如果参数中没有渲染
    if (!vm.$options.render) {
      ...
    }
    //执行生命周期函数 beforeMount
    callHook(vm, "beforeMount");
    //更新组件
    var updateComponent;
    //如果开发环境
    if ("development" !== "production" && config.performance && mark) {
      // 开发环境
    } else {
      // 更新视图
      updateComponent = function() {
        //直接更新view试图
        vm._update(
          vm._render(), //先执行_render,返回vnode
          hydrating
        );
      };
    }

    // we set this to vm._watcher inside the watcher's constructor
    // since the watcher's initial patch may call $forceUpdate (e.g. inside child
    // component's mounted hook), which relies on vm._watcher being already defined
    //我们将其设置为vm。在观察者的构造函数中
    //因为观察者的初始补丁可能调用$forceUpdate(例如inside child)
    //组件的挂载钩子)，它依赖于vm。_watcher已经定义
    //创建观察者
    new Watcher(
      vm, //vm vode
      updateComponent, //数据绑定完之后回调该函数。更新组件函数 更新 view试图
      noop, //回调函数
      null, //参数
      true //是否渲染过得观察者
      /* isRenderWatcher */
    );
    hydrating = false;

    // manually mounted instance, call mounted on self
    // mounted is called for render-created child components in its inserted hook
    //手动挂载实例，调用挂载在self上
    // 在插入的钩子中为呈现器创建的子组件调用// mount
    if (vm.$vnode == null) {
      vm._isMounted = true;
      //执行生命周期函数mounted
      callHook(vm, "mounted");
    }

    return vm;
  }


```

### Vue 中双向数据绑定的实现原理

```javascript
// vue 双向绑定原理
// 实现一个双向绑定
function observe(data) {
  if (!data || typeof data !== "object") {
    return;
  }
  Object.keys(data).forEach((key, index) => {
    defineReactive(data, key, data[key]);
  });
}
function defineReactive(data, key, value) {
  // 获取递归获取子属性
  observe(value);
  let dep = new Dep();
  // 主要使用 defineProperty方法
  Object.defineProperty(data, key, {
    set: function (newVal) {
      if (value == newVal) {
        return;
      }
      console.log("set " + newVal);
      value = newVal;
      dep.notify();
    },
    get: function () {
      if (Dep.target) {
        dep.add(Dep.target);
      }
      return value;
    },
  });
}

function Dep() {
  this.subs = [];
}
Dep.prototype.add = function (sub) {
  this.subs.push(sub);
};

Dep.prototype.notify = function () {
  this.subs.forEach(sub => {
    console.log(sub);
    sub.update();
  });
};
Dep.target = null;

function Wacther(vm, prop, callback) {
  this.vm = vm;
  this.prop = prop;
  this.value = this.get();
  this.callback = callback;
}

// 观察器
Wacther.prototype = {
  update: function (val) {
    let oldVal = this.value;
    let value = this.vm.$data[this.prop];

    if (oldVal !== value) {
      this.value = value;
      this.callback(value);
    }
  },
  get: function () {
    Dep.target = this;
    let value = this.vm.$data[this.prop];
    Dep.target = null;
    return value;
  },
};

function Vue(options, prop) {
  this.$data = options.data;
  this.prop = prop;
  this.$el = document.querySelector(options.el);
  this.init();
}

Vue.prototype.init = function () {
  observe(this.$data);
  console.log(this.$data);
  this.$el.textContent = this.$data.name;

  new Wacther(this, this.prop, value => {
    this.$el.textContent = value;
  });
};

var vm = new Vue(
  {
    el: "#link",
    data: {
      name: "123456",
    },
  },
  "name"
);
```

### Vue 的生命周期

1. beforeCreate
   > 创建前 此时刚刚实例化完 Vue 事件监听 和 数据观测之前
2. created
   > 创建后 此时 完成了事件监听 和数据观测 通常用于数据初始化 在页面 created 是请求后端接口
3. beforeMount
   > 挂载前 在模板挂载之前 此时还无法操作 dom
4. mounted
   > 挂载后 此时模板 template 已经渲染完成即模板渲染成 html 在此之后可以操作 dom 节点
5. beforeUpdate
   > 更新前 发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器
6. updated
   > 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子
7. activated
   > 被 keep-alive 缓存的组件激活时调用
8. deactivated
   > 被 keep-alive 缓存的组件停用时调用
9. beforeDestroy
   > 实例销毁前 在这一步，实例仍然完全可用
10. destroyed
    > 实例销毁后 该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁
11. errorCaptured 2.5.0+
    > 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播

### Vue 组件间通信

#### 1 Provide Inject 双向绑定

```javascript
   // 父组件
  data(){
    return {
      // 父组件必须为对象等引用类型 数据将会双向绑定
      // 基础数据类型 不会双向绑定
      // 如 testData: '测试数据...'
      testData: {
        test: '测试数据...'
      }
    }
  },
  provide() {
    return {
      provideTest: this.testData,
    };
  },

  // 子组件 接收方式
  // 1
  inject: ["provideTest"],
  // 2
  inject: {
    provideTest: {
      default: "default"
    }
  },

```

#### 2 Vue.observable 双向绑定

> vue.observable 仅在 2.6 版本及以上

```javascript
// 增加 store.js文件
import Vue from "vue";
let store = Vue.observable({
  name: "111",
  age: 28,
});

let mutations = {
  addAge: function (count) {
    store.age += count;
  },
  changeName: function (name) {
    store.name = name;
  },
};
export { store, mutations };

// 在组件中引入即可 类似VUEX文件引入
```

#### 3 $props $emit

> 父组件通过 props 传递数据 子组件通过事件 $emit 来接受事件和参数

**props 数据双向绑定**

#### 4 VUEX

```javascript

```

#### 5 Bus 文件

> 和 2 类似

```javascript
// bus.js
import Vue from "vue";

export default new Vue();
// 在子组件中 通过 $on来监听
```

#### 6 $attrs $listeners 文件

> 使用方法类似 $emit 和 props

> 所有父组件传递的未被 props 申明的变量都会在子组件的$attrs 中 所有监听事件都在 $listeners 中

```javascript
// 父组件

<template>
  <div>
    <div>AttrsListeners</div>
    <AttrsChildren
      :title="title"
      :bar="bar"
      :foo="foo"
      @test="test"
      baz="2312"
    ></AttrsChildren>
  </div>
</template>


// 子组件 AttrsChildren
<template>
  <div class="list">
    <div class="item">
      <div class="title">child1</div>
      <div>title: {{ title }}</div>
      <div>attrs属性：{{ $attrs }}</div>
      <div>listeners监听事件： {{ $listeners }}</div>
      /* 可以通过此方法将$attrs再次传入子组件中 */
      <AttrsChildren2 v-bind="$attrs" v-on="$listeners"></AttrsChildren2>
    </div>
  </div>
</template>

export default {
  data() {
    return {};
  },
  props: {
    title: String
  },
  // inheritAttrs true 将
  inheritAttrs: false,
  components: {
    AttrsChildren2
  },
  created() {
    // 未在 props中定义的变量 都在$attrs中
    // $attrs { bar: "bar", foo: "foo", baz: "2312"}
    // 可以通过此方法将$attrs再次传入子组件中

    // 所有监听事件 都在 $listeners中
    console.log(this.$listeners, this.$attrs);
  }
};


```

#### 7 Slot 插槽

```javascript
// 父组件
<template>
  <div>
    <div>Slot</div>
    <SlotChild1>
      <template v-slot:default="slotProps">
        <div class="un">默认插槽 {{ slotProps }}</div>
      </template>
      <template v-slot:slot1>
        <div class="name-slot">具名插槽</div>
      </template>
    </SlotChild1>
  </div>
</template>

//子组件 SlotChild1
<template>
  <div>
    <div>Slot1</div>
    <slot v-bind:user="user1">默认内容</slot>
    <slot name="slot1"></slot>
  </div>
</template>
  data() {
    return {
      user1: {
        foo: "foo",
        bar: "bar"
      }
    };
  },
```

### Vue React 区别

### Vue 计算属性

#### 计算属性和方法

1. 主要区别计算属性 可以缓存 ，method 不能
2. 一般情况下计算属性不能传参，但可以通过闭包来传参

```javascript
  <div :data="func(a,b,c)"> </div>
  data() {
    return {
      a: 1,
      b: 2,
      c: 3
    }
  },

  computed: {
    func(){
      return func(a,b,c){
        return a + b + c
      }
    }
  }

```

### Vue 内部闭包 cached 方法

```javascript
// 使用闭包缓存住cache中的值
// 若已存在直接返回 若不存在返回方法调用的值 并且赋值给cache以供下次判断
function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
// vue中利用此函数的方法 都利用了cached函数缓存了所有判断过的值
// 此方法将连接符-转化为驼峰法
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : "";
  });
});

// 将首字母变成大写
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
```

### Vue 内部任务延迟实现

> V 2.6.12 中先使用 Promise -> MutationObserver -> setImmediate -> setTimeout

> V 2.5.16
> 宏任务： macroTimerFunc = setImmediate -> MessageChannel -> setTimeout  
> 微任务： microTimerFunc = Promise 如 Promise 不存在 返回宏任务

#### 在 2.6 中 VUE 主要使用的是微任务触发 而在 2.5 中使用宏任务和微任务结合使用

---

### Vue 内部 $nextTick 方法

```javascript
function nextTick(cb, ctx) {
  //cb 回调函数
  //ctx this的指向
  var _resolve;
  //添加一个回调函数到队列里面去

  // callbacks 更新任务的回调队列
  // 每次dom更新或者存在其他异步任务 会在回调队列中依次执行
  callbacks.push(function () {
    if (cb) {
      //如果cb存在 并且是一个函数就执行
      try {
        cb.call(ctx);
      } catch (e) {
        //如果不是函数则报错
        handleError(e, ctx, "nextTick");
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    //执行异步宏任务
    if (useMacroTask) {
      macroTimerFunc(); //异步触发 或者 实现观察者 触发  callbacks 队列中的函数
    } else {
      microTimerFunc(); //异步触发 或者 实现观察者 触发  callbacks 队列中的函数
    }
  }
  if (!cb && typeof Promise !== "undefined") {
    //如果回调函数不存在 则声明一个Promise 函数
    return new Promise(function (resolve) {
      _resolve = resolve;
    });
  }
}
// 将next方法绑到 Vue上
Vue.prototype.$nextTick = function (fn) {
  return nextTick(fn, this);
};
```

```javascript
// vue中调用
this.$nextTick(() => {
  console.log(this);
});

// 或
this.$nextTick().then(_this => {
  // nextTick内不传参数 会返回promise
  console.log(_this);
});

// 或
this.$nextTick(
  (function (_this) {
    // 立即执行返回false
    // 注意此处 cb未绑定this 没有this
    // 需在立即执行 绑定this
    console.log(_this);
    return false;
  })(this)
).then(_this => {
  console.log(_this);
});
```

### Vue 手动设置的 get set

> 主要通过 defineReactive 方法 里 Object.getOwnPropertyDescriptor 判断对象上是否有 set 或者 get 如果有值 那就直接返回设置的 set 和 get

```javascript
// 如果 a属性下有get和set 就会覆盖原来的get 和set
computed: {
  a: {
    get(){

    },
    set() {

    }
  }
}

```

```javascript
/**
 * Define a reactive property on an Object.
 * 在对象上定义一个无功属性。
 * 更新数据
 * 通过defineProperty的set方法去通知notify()订阅者subscribers有新的值修改
 * 添加观察者 get set方法
 */
function defineReactive(
  obj, //对象
  key, //对象的key
  val, //监听的数据 返回的数据
  customSetter, //  日志函数
  shallow //是否要添加__ob__ 属性
) {
  //实例化一个主题对象，对象中有空的观察者列表
  var dep = new Dep();
  //获取描述属性
  var property = Object.getOwnPropertyDescriptor(obj, key);
  var _property = Object.getOwnPropertyNames(obj); //获取实力对象属性或者方法，包括定义的描述属性

  if (property && property.configurable === false) {
    return;
  }
  var getter = property && property.get;

  if (!getter && arguments.length === 2) {
    val = obj[key];
  }
  var setter = property && property.set;
  //判断value 是否有__ob__    实例化 dep对象,获取dep对象  为 value添加__ob__ 属性递归把val添加到观察者中  返回 new Observer 实例化的对象
  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        //Dep.target 静态标志 标志了Dep添加了Watcher 实例化的对象
        //添加一个dep
        dep.depend();
        if (childOb) {
          //如果子节点存在也添加一个dep
          childOb.dep.depend();
          if (Array.isArray(value)) {
            //判断是否是数组 如果是数组
            dependArray(value); //则数组也添加dep
          }
        }
      }
      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return;
      }
      if ("development" !== "production" && customSetter) {
        customSetter();
      }
      if (setter) {
        // property = Object.getOwnPropertyDescriptor(obj, key);
        // setter = property && property.set;
        setter.call(obj, newVal);
      } else {
        //新的值直接给他
        val = newVal;
      }
      //observe 添加 观察者
      childOb = !shallow && observe(newVal);
      //更新数据
      dep.notify();
    },
  });
}
```

### Vue provide Inject

> Vue 中主要使用 initInjections(vm) initProvide(vm) 这两个方法来初始化 provide inject

```javascript
// 1. 首先执行initInjections 主要获取 inject属性值, 获取后循环$parent属性 如果存在_provide属性则跳出直接赋值 如果没有_provide属性 则再取$parent属性直到最外层 (最外层vm的$parent为undefined) 然后获取其默认的default属性

// 首先会进行 normalizeInject 方法调用
//  将
// inject: {
//         aaa: {
//           default: 123
//         },
//         bbb: {
//           default: 2323
//         }
//  }

// 转化为
// {
//     "aaa": {
//         "from": "aaa",
//         "default": 123
//     },
//     "bbb": {
//         "from": "bbb",
//         "default": 2323
//     }
// }
// 核心代码
var provideKey = inject[key].from; // 获取key的值
var source = vm;
while (source) {
  if (source._provided && hasOwn(source._provided, provideKey)) {
    //判断_provided 存在么 并且是对象的时候，并且实例化属性provideKey 存在
    result[key] = source._provided[provideKey]; //获取值 存起来
    break;
  }
  source = source.$parent; //循环父节点
}
if (!source) {
  //如果vm 不存在
  if ("default" in inject[key]) {
    // 判断default key存在inject[key]中么
    var provideDefault = inject[key].default; //如果存在则获取默认default的值
    result[key] =
      typeof provideDefault === "function" //如果是函数则执行
        ? provideDefault.call(vm)
        : provideDefault;
  } else {
    warn('Injection "' + key + '" not found', vm);
  }
}

//  initProvide(vm) 就是直接判断有没有provide属性 有则给其vm赋值_provide
function initProvide(vm) {
  var provide = vm.$options.provide; //provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。
  if (provide) {
    //判断provide 存在
    vm._provided =
      typeof provide === "function" //判断是否是函数如果是函数则执行
        ? provide.call(vm)
        : provide;
  }
}
```

### Vue $forceUpdated

> 直接调用的\_watcher 监听器的 update 方法 update 方法执行 Watcher.prototype.run

### Vue use 安装插件

> 主要通过 initUse(Vue) 方法

```javascript
// 核心代码
function initUse(Vue) {
  //安装 Vue.js 插件。
  Vue.use = function (plugin) {
    var installedPlugins =
      this._installedPlugins || (this._installedPlugins = []);
    if (installedPlugins.indexOf(plugin) > -1) {
      //判断是否已经安装过插件了
      return this;
    }
    // additional parameters//额外的参数
    var args = toArray(arguments, 1); //变成真的数组

    args.unshift(this); //在前面添加Vue

    if (typeof plugin.install === "function") {
      //如果plugin.install 是个函数 则执行安装
      //传入参数
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === "function") {
      //如果plugin 是个函数则安装
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin); // 将已经安装过的插件添加到队列去
    return this;
  };
}

// 调用方法

class testPlugin {
  install(Vue, arg1,arg2...) {
    // 源码中回通过apply方法把所有参数传入install方法中
    // 固定第一个参数为Vue 其他参数依次传入
  }
}

Vue.use(new testPlugin(),arg1,arg2...)
```

### Vue 模板编译

1. 首先通过 执行 Vue.prototype.$mount 执行 挂载方法

2. 之后执行 compileToFunctions() 获取其返回值 ref `编译过程详解在下方`

```javascript
// 核心代码
var ref = compileToFunctions(
  template, //模板字符串
  {
    shouldDecodeNewlines: shouldDecodeNewlines, //flase //IE在属性值中编码换行，而其他浏览器则不会
    shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref, //true chrome在a[href]中编码内容
    delimiters: options.delimiters, //改变纯文本插入分隔符。修改指令的书写风格，比如默认是{{mgs}}  delimiters: ['${', '}']之后变成这样 ${mgs}
    comments: options.comments, //当设为 true 时，将会保留且渲染模板中的 HTML 注释。默认行为是舍弃它们。
  },
  this
);

//compileToFunctions  内部执行方法
var compileToFunctions = createCompilerCreator(function baseCompile()...)(baseOptions).compileToFunctions;

//所以编译过程
var ref = createCompilerCreator(function baseCompile()...)(baseOptions).compileToFunctions(template,{...},this);


// ref 值 为
{
  render: render; // 将获取Vue中的render函数 如果没有render函数 则获取其挂载的节点 将节点中的模板语法进行编译
  // 最终获取的render 函数这个样子
  // (function anonymous(
  // ) {
  // with(this){return _c('div',{attrs:{"id":"app"}},[_c('div',[_v("a: "+_s(a))]),_v(" "),_c('div',[_v("b: "+_s(b))]),_v(" "),_c('div',[_v("aplus"+_s(aPlus))]),_v(" "),_c('div',[_v("c: "+_s(c))]),_v(" "),_c('div',{class:{'test-class': 'class.test'}},[_v("测试class")]),_v(" "),_c('div',{staticClass:"btn",on:{"click":click}},[_v("点击事件测试")]),_v(" "),_c('div',{staticClass:"btn",on:{"click":clickGetSet}},[_v("测试getset")]),_v(" "),_c('coma')],1)}
  // })
  // 其实就是将html挂载模板编译成了 render 函数 这个render函数和自己定义的render函数一样 执行返回的就是虚拟的dom
  // 类似这样
  // {
  // asyncFactory: undefined
  // asyncMeta: undefined
  // children: (15) [VNode, VNode, VNode, VNode, VNode, VNode, VNode, VNode, VNode, VNode, VNode, VNode, VNode, VNode, VNode]
  // componentInstance: undefined
  // componentOptions: undefined
  // context: Vue {_uid: 0, _isVue: true, $options: {…}, _renderProxy: Proxy, _self: Vue, …}
  // data: {
  //   attrs: {id: "app"}
  // }
  // elm: undefined
  // fnContext: undefined
  // fnOptions: undefined
  // fnScopeId: undefined
  // isAsyncPlaceholder: false
  // isCloned: false
  // isComment: false
  // isOnce: false
  // isRootInsert: true
  // isStatic: false
  // key: undefined
  // ns: undefined
  // parent: undefined
  // raw: false
  // tag: "div"
  // text: undefined
  // child: undefined
  // }
  staticRenderFns: staticRenderFns;
}
```

3. 获取 ref 后 再执行挂载方法,即执行 Vue.prototype.\_update 方法更新视图
4. Vue.prototype.\_update 主要执行 **patch**方法更新对比 dom 节点

#### 编译语法过程解析 ref 执行过程

> var ref = createCompilerCreator(function baseCompile()...)(baseOptions).compileToFunctions(template,{...},this);

1. 先执行 createCompilerCreator(function baseCompile(){})(baseoption) 返回的是一个对象 对象中 有 complie 和 compileToFunctions 两个方法

```javascript
// 1 ------

//  挂载阶段执行
var ref = compileToFunctions(
  template, //模板字符串
  {
    shouldDecodeNewlines: shouldDecodeNewlines, //flase //IE在属性值中编码换行，而其他浏览器则不会
    shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref, //true chrome在a[href]中编码内容
    delimiters: options.delimiters, //改变纯文本插入分隔符。修改指令的书写风格，比如默认是{{mgs}}  delimiters: ['${', '}']之后变成这样 ${mgs}
    comments: options.comments, //当设为 true 时，将会保留且渲染模板中的 HTML 注释。默认行为是舍弃它们。
  },
  this
);

// 2 ------

var compileToFunctions = ref$1.compileToFunctions;

var ref$1 = createCompiler(baseOptions);

var createCompiler = createCompilerCreator(
  function baseCompile(
    template, //string模板
    options //
  ) {
    //返回ast模板对象
    var ast = parse(template.trim(), options);
    if (options.optimize !== false) {
      optimize(ast, options);
    }
    var code = generate(ast, options);
    return {
      ast: ast, //ast 模板
      render: code.render, //code 虚拟dom需要渲染的参数函数
      staticRenderFns: code.staticRenderFns //空数组
    };
  }
);

// 所以
compileToFunctions = createCompilerCreator(function baseCompile())(baseOptions).compileToFunctions;
// 下面具体查看 createCompilerCreator方法的返回值

// 3 ------
  function createCompilerCreator(
    baseCompile //基本的编译函数
  ) {
    // 返回一个 createCompiler 编译方法
  return function createCompiler(baseOptions) {

    function compile(
      template, //字符串模板
      options //options 参数
    ) {
      .... // 省略部分
      var compiled = baseCompile(
        template, //template 模板
        finalOptions //finalOptions 基本参数  为虚拟dom添加基本需要的属性
      );
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled;
    }
    // 在执行返回一个 对象
    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    };
  };
}

compileToFunctions = createCompiler(function baseCompile())(baseOptions).compileToFunctions;

// createCompiler(function baseCompile())(baseOptions) 的返回值 为
//   {
//      compile: compile,
//      compileToFunctions: createCompileToFunctionFn(compile)
//   };

// 最后
compileToFunctions = createCompileToFunctionFn(compile)


```

```javascript
// 简化版基本编译
function baseCompile() {
  var ast = parse(template.trim(), options);
  // 返回ast树 即parse -> parseHtml后的数据格式
  // ast数会对一些指令做一些基本处理 但不会渲染指令 如v-for 其模板不会渲染多个
  // 类似
  // {
  //  attrs: [{…}]
  //  attrsList: [{…}]
  //  attrsMap: {id: "app"}
  //  children: [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]
  //  parent: undefined
  //  plain: false
  //  static: false
  //  staticRoot: false
  //  tag: "div"
  //  type: 1
  // }
  var code = generate(ast, options);
  // generate 即将ast树渲染成
  // with(this){return _c('div',{attrs:{"id":"app"}},[_c('div',[_v("a: "+_s(a))]),_v(" "),_c('div',[_v("b: "+_s(b))]),_v(" "),_c('div',[_v("aplus"+_s(aPlus))]),_v(" "),_c('div',[_v("c: "+_s(c))]),_v(" "),_c('div',{class:{'test-class': 'class.test'}},[_v("测试class")]),_v(" "),_c('div',{staticClass:"btn",on:{"click":click}},[_v("点击事件测试")]),_v(" "),_c('div',{staticClass:"btn",on:{"click":clickGetSet}},[_v("测试getset")]),_v(" "),_c('coma')],1)}
  return {
    ast: ast, //ast 模板
    render: code.render, //code 虚拟dom需要渲染的参数函数
    staticRenderFns: code.staticRenderFns, //空数组
  };
}

function createCompilerCreator(
  baseCompile //基本的编译函数 即baseCompile方法
) {
  // 返回的是一个函数 参数是之前传的baseOption
  return function createCompiler(baseOptions) {
    // 有一个complie 方法
    function compile(
      template, //字符串模板
      options //options 参数
    ) {
      // 会执行之前的baseCompile
      var compiled = baseCompile(
        template, //template 模板
        finalOptions //finalOptions 基本参数  为虚拟dom添加基本需要的属性
      );
      // 除去baseComplie的返回值之外还有其他 如 compiled.errors = errors; compiled.tips = tips;此处省略
      return compiled;
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile),
    };
  };
}
```

2. 再执行 compileToFunctions(template,{...},this);

> 即执行 createCompileToFunctionFn(compile)(template,{...},this);

```javascript
function createCompileToFunctionFn(compile) {
  var cache = Object.create(null);

  return function compileToFunctions(
    template, //字符串模板
    options, //参数
    vm //vmnode
  ) {
    var key = options.delimiters
      ? String(options.delimiters) + template
      : template;
    if (cache[key]) {
      return cache[key];
    }
    var compiled = compile(
      template, //模板字符串
      options //参数
    );
    var res = {};
    var fnGenErrors = [];
    //把字符串 转化成真正的js并且以 函数的方式导出去
    res.render = createFunction(compiled.render, fnGenErrors);
    //字符串转化js 创建一个集合函数
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors);
    });
    // 此处利用闭包 缓存住编译的对象
    // 如果相同则不需编译直接返回
    // cache 的key 为 template 的模板内容 '<div> ......</div>' 未编译前的节点字符串
    // res = {
    //   render: function() ...,   render函数
    //   staticRenderFns: []
    // }
    return (cache[key] = res);
  };
}
```

#### Vue dom 解析语法详解

> 主要是 parse 方法 -> parseHTML 方法做主要解析 html 模板 解析后 返回 root 根节点

```javascript
  // parseHtml方法 使用大量正则表达式匹配将template每一行进行匹配 之后返回ast树形结构
  // root 返回值 大致是这样
  {
    attrs: [{…}],
    attrsList: [{…}],
    attrsMap: {id: "app"},
    children:[{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}],
    parent: undefined,
    plain: false,
    static: false,
    staticRoot: false,
    tag: "div",
    type: 1,
  }

```

#### Vue patch dom 更新语法详解

> 主要是 patch 语法 执行 vm.\_\_patch\_\_

1. 执行顺序

```javascript
vm.$el = vm.__patch__(prevVnode, vnode);

Vue.prototype.__patch__ = inBrowser ? patch : noop; // noop为空函数

// __patch__  浏览器环境下 执行patch
var patch = createPatchFunction({
  nodeOps: nodeOps,
  modules: modules,
});

// 实际执行

vm.$el = vm.createPatchFunction({ nodeOps: nodeOps, modules: modules })(
  prevNode,
  vnode
);
```

2. 两个参数 nodeOps platformModules

```javascript
// 两个参数 nodeOps platformModules
var nodeOps = Object.freeze({
  createElement: createElement$1, //创建一个真实的dom
  createElementNS: createElementNS, //创建一个真实的dom svg方式
  createTextNode: createTextNode, // 创建文本节点
  createComment: createComment, // 创建一个注释节点
  insertBefore: insertBefore, //插入节点 在xxx  dom 前面插入一个节点
  removeChild: removeChild, //删除子节点
  appendChild: appendChild, //添加子节点 尾部
  parentNode: parentNode, //获取父亲子节点dom
  nextSibling: nextSibling, //获取下一个兄弟节点
  tagName: tagName, //获取dom标签名称
  setTextContent: setTextContent, //  //设置dom 文本
  setStyleScope: setStyleScope, //设置组建样式的作用域
});

var platformModules = [
  attrs, // attrs包含两个方法create和update都是更新设置真实dom属性值 {create: updateAttrs, /*创建属性*/ update: updateAttrs  /*更新属性 */}
  klass, //klass包含类包含两个方法create和update都是更新calss。其实就是updateClass方法。 设置真实dom的class
  events, //更新真实dom的事件
  domProps, //更新真实dom的props 属性值
  style, // 更新真实dom的style属性。有两个方法create 和update 不过函数都是updateStyle更新真实dom的style属性值.将vonde虚拟dom的css 转义成并且渲染到真实dom的css中
  transition, // 过度动画

  /* 其实就是加上了两个基础模块 */
  // ref,
  // directives,
];

//baseModules 包括了 ref创建，更新 ， 销毁 函数 和 directives自定义指令 创建 ，更新，销毁函数
var modules = platformModules.concat(baseModules);

var baseModules = [
  ref, //ref创建，更新 ， 销毁 函数
  directives, //自定义指令 创建 ，更新，销毁函数
];
var directives = {
  create: updateDirectives, //创建指令
  update: updateDirectives, //更新指令
  destroy: function unbindDirectives(vnode) {
    //销毁指令
    updateDirectives(vnode, emptyNode);
  },
};
var ref = {
  create: function create(_, vnode) {
    //创建注册一个ref
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    //更新ref
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true); //先删除
      registerRef(vnode); //在添加
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true); //删除销毁ref
  },
};
```

3. createPatchFunction 函数
   - 主要是 patch 语法
     1. 如果 vnode 不存在但是 oldVnode 存在，说明意图是要销毁老节点，那么就调用 invokeDestroyHook(oldVnode)来进行销毁
     2. 如果没有定义旧的 vond 直接用 createElm 创建节点 新建组件在此渲染
     3. 更新组件进行 patch 比较
     4. 初始化节点 即挂载#app 时

```javascript
function createPatchFunction(backend) {
  return function patch(
    oldVnode, //旧的vonde或者是真实的dom. 或者是没有
    vnode, //新的vode
    hydrating,
    removeOnly, //是否要全部删除标志
    parentElm, //父节点 真实的dom
    refElm //当前节点 真实的dom
  ) {
    if (isUndef(vnode)) {
      //如果没有定义新的vonde
      if (isDef(oldVnode)) {
        //如果没有定义旧的vonde
        invokeDestroyHook(oldVnode); //如果vnode不存在但是oldVnode存在，说明意图是要销毁老节点，那么就调用invokeDestroyHook(oldVnode)来进行销毁
      }
      /* 1 ==========================销毁 */
      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = []; //vonde队列 如果vnode上有insert钩子，那么就将这个vnode放入insertedVnodeQueue中作记录，到时再在全局批量调用insert钩子回调
    if (isUndef(oldVnode)) {
      /* 2 ========================== 新建组件*/

      //如果没有定义旧的vonde
      // empty mount (likely as component), create new root element 空挂载(可能作为组件)，创建新的根元素
      isInitialPatch = true;
      createElm(
        //创建节点
        vnode, //虚拟dom
        insertedVnodeQueue, //vonde队列空数组
        parentElm, //真实的 父节点
        refElm //当前节点
      );
    } else {
      // oldVnode.nodeType 只有再初次渲染即挂载 #app 的时候才存在
      // 因为初次挂载 挂载的是vm.$el 而之后都是 挂载 Vnode虚拟节点 虚拟节点中没有nodeType属性
      var isRealElement = isDef(oldVnode.nodeType); //获取 真实的dom 类型
      if (
        !isRealElement && //如果获取不到真实的dom 类型
        sameVnode(oldVnode, vnode) //sameVnode(oldVnode, vnode)2个节点的基本属性相同，那么就进入了2个节点的diff过程。
      ) {
        /* 3 ========================== 更新*/

        //修补现有根节点
        patchVnode(
          oldVnode,
          vnode,
          insertedVnodeQueue, //vonde队列
          removeOnly //是否要全部删除标志
        );
      } else {
        /* 4 ========================== 初始化*/
        if (isRealElement) {
          /* 此处服务端渲染内容略过 */
          oldVnode = emptyNodeAt(oldVnode);
        }

        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);

        // create new node
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm$1,
          nodeOps.nextSibling(oldElm)
        );

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        // destroy old node
        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}
```

4. patchVnode 语法分析

```javascript
// oldVnode 和 vnode 进行属性值的更新 包括属性 类名 监听事件 样式 指令等 即
// ƒ updateAttrs(oldVnode, vnode)
// ƒ updateClass(oldVnode, vnode)
// ƒ updateDOMListeners(oldVnode, vnode)
// ƒ updateDOMProps(oldVnode, vnode)
// ƒ updateStyle(oldVnode, vnode)
// ƒ update(oldVnode, vnode)
// updateDirectives(oldVnode, vnode)
// 之后执行 updateChildren 方法
function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
  if (oldVnode === vnode) {
    //如果他们相等直接返回
    return;
  }
  var elm = (vnode.elm = oldVnode.elm); //获取真实的dom

  if (isTrue(oldVnode.isAsyncPlaceholder)) {
    if (isDef(vnode.asyncFactory.resolved)) {
      hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
    } else {
      vnode.isAsyncPlaceholder = true;
    }
    return;
  }

  // reuse element for static trees.
  // note we only do this if the vnode is cloned -
  // if the new node is not cloned it means the render functions have been
  // reset by the hot-reload-api and we need to do a proper re-render.
  if (
    isTrue(vnode.isStatic) &&
    isTrue(oldVnode.isStatic) &&
    vnode.key === oldVnode.key &&
    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
  ) {
    vnode.componentInstance = oldVnode.componentInstance;
    return;
  }

  var i;
  var data = vnode.data;
  if (isDef(data) && isDef((i = data.hook)) && isDef((i = i.prepatch))) {
    i(oldVnode, vnode);
  }

  var oldCh = oldVnode.children; // 旧子节点
  var ch = vnode.children; // 新子节点
  if (isDef(data) && isPatchable(vnode)) {
    for (i = 0; i < cbs.update.length; ++i) {
      // 把钩子函数添加到cbs队列中
      // cbs={
      //'create':[],
      //'activate':[],
      //'update':[],
      //'remove':[],
      //'destroy:[]
      //    }
      //
      //  将vnode 所有属性更新一遍
      // update = [
      // ƒ updateAttrs(oldVnode, vnode)
      // ƒ updateClass(oldVnode, vnode)
      // ƒ updateDOMListeners(oldVnode, vnode)
      // ƒ updateDOMProps(oldVnode, vnode)
      // ƒ updateStyle(oldVnode, vnode)
      // ƒ update(oldVnode, vnode)
      // ƒ updateDirectives(oldVnode, vnode)
      // ]
      cbs.update[i](oldVnode, vnode);
    }
    if (isDef((i = data.hook)) && isDef((i = i.update))) {
      i(oldVnode, vnode);
    }
  }
  if (isUndef(vnode.text)) {
    // 如果含有旧子元素和新子元素都存在
    if (isDef(oldCh) && isDef(ch)) {
      // 并且不相等 则更新子元素
      if (oldCh !== ch) {
        // 更新子元素
        updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
      }
    } else if (isDef(ch)) {
      // 新子元素存在 旧子元素不存在

      if (isDef(oldVnode.text)) {
        // 设置文本节点的值为空
        nodeOps.setTextContent(elm, "");
      }
      // 创建新元素
      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
    } else if (isDef(oldCh)) {
      // 旧子元素存在 新子元素不存在 则表示删除 则删除旧元素
      removeVnodes(elm, oldCh, 0, oldCh.length - 1);
    } else if (isDef(oldVnode.text)) {
      nodeOps.setTextContent(elm, "");
    }
  } else if (oldVnode.text !== vnode.text) {
    // 如果含有旧子元素和新子元素都不存在 比较文本 不相同则更新文本节点
    nodeOps.setTextContent(elm, vnode.text);
  }
  if (isDef(data)) {
    if (isDef((i = data.hook)) && isDef((i = i.postpatch))) {
      i(oldVnode, vnode);
    }
  }
}
```

5. updateChildren 更新子节点

```javascript
function updateChildren(
  parentElm,
  oldCh,
  newCh,
  insertedVnodeQueue,
  removeOnly
) {
  var oldStartIdx = 0; // 旧子节点初始索引
  var oldEndIdx = oldCh.length - 1; // 旧子节点结束索引
  var oldStartVnode = oldCh[0]; // 旧第一个节点
  var oldEndVnode = oldCh[oldEndIdx]; // 旧最后节点

  var newStartIdx = 0; // 新子节点初始索引
  var newEndIdx = newCh.length - 1; // 新子节点结束索引
  var newStartVnode = newCh[0]; // 新第一个节点
  var newEndVnode = newCh[newEndIdx]; // 新最后节点
  var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

  var canMove = !removeOnly;

  {
    checkDuplicateKeys(newCh); // 检查key是否重复 会导致更新问题
  }
  // 关键在于这里的diff算法比较
  // 首先定义了两个双指针
  // 一个为旧子节点的头尾 一个新子节点的头尾
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (isUndef(oldStartVnode)) {
      oldStartVnode = oldCh[++oldStartIdx];
    } else if (isUndef(oldEndVnode)) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (sameVnode(oldStartVnode, newStartVnode)) {
      // 首节点相等 先两个节点比较 patchVnode 具体patchVnode 算法看步骤4
      // 再将首节点索引后移一位 并更新startVnode

      /*  sameVnode方法 会判断节点的基本属性 如key tag data 等
           *    function sameVnode(a, b) {
                  return (
                    a.key === b.key && //如果a的key 等于b的key
                    ((a.tag === b.tag && // 如果a的tag 等于b的tag
                    a.isComment === b.isComment && // 如果a和b 都是注释节点
                    isDef(a.data) === isDef(b.data) && //如果a.data 和 b.data 都定义后，是组件，或者是都含有tag属性
                      sameInputType(a, b)) || //相同的输入类型。判断a和b的属性是否相同
                      (isTrue(a.isAsyncPlaceholder) && //判断是否是异步的
                        a.asyncFactory === b.asyncFactory &&
                        isUndef(b.asyncFactory.error)))
                  );
                }
           *
           */

      // 头部节点相同 就是不改变原来的头部dom元素的顺序
      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (sameVnode(oldEndVnode, newEndVnode)) {
      // 尾节点相等 先两个节点比较 patchVnode 具体patchVnode 算法看步骤4
      // 再将尾索引前移一位 并更新endVnode

      // 也不改变dom元素顺序
      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldStartVnode, newEndVnode)) {
      // 当 旧头部子节点 和新尾部子节点相同时
      // 例 old   a b c
      //    new   b c a
      // 第一次 循环 oldStartVnode = a  newEndVnode = a  oldEndVnode = c 在oldEndVnode 后插入a
      // 即 改变元素位置 因为 新子元素 a在最后面 需将其移到最后
      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
      // 在 oldEndVnode.elm 的下一个元素之前插入 oldStartVnode.elm
      // 即 在 oldEndVnode.elm 之后插入 oldStartVnode.elm
      canMove &&
        nodeOps.insertBefore(
          parentElm,
          oldStartVnode.elm,
          nodeOps.nextSibling(oldEndVnode.elm)
        );
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldEndVnode, newStartVnode)) {
      // 同上 当旧尾部节点和新头部节点相同时 将旧尾部移到头部前

      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
      canMove &&
        nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      //  没有任何匹配
      if (isUndef(oldKeyToIdx)) {
        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
      }
      //  先从 旧子节点找 和 newStartVnode的key值有没有相同的
      //  找不到key 在 遍历 旧头节点 到 旧尾节点 依次判断是否有相同的
      idxInOld = isDef(newStartVnode.key)
        ? oldKeyToIdx[newStartVnode.key]
        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx); // 从旧的节点中寻找和 newStartVnode 相同的节点
      if (isUndef(idxInOld)) {
        // 找不到 旧新建节点
        createElm(
          newStartVnode,
          insertedVnodeQueue,
          parentElm,
          oldStartVnode.elm,
          false,
          newCh,
          newStartIdx
        );
      } else {
        //  找到 判断找到的节点和 newStartVnode是否相同
        vnodeToMove = oldCh[idxInOld];
        if (sameVnode(vnodeToMove, newStartVnode)) {
          // 相同
          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);
          oldCh[idxInOld] = undefined;
          canMove &&
            nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
        } else {
          // 不相同创建新节点
          createElm(
            newStartVnode,
            insertedVnodeQueue,
            parentElm,
            oldStartVnode.elm,
            false,
            newCh,
            newStartIdx
          );
        }
      }
      newStartVnode = newCh[++newStartIdx];
    }
  }

  if (oldStartIdx > oldEndIdx) {
    // 添加节点
    // 这个在 新子元素长度比旧子元素长 即增加了内容时触发 此时 addVnodes 为增加的元素
    // 或者  新子元素和旧子元素没有发生顺序变化 这时 refElm 为null 即不添加新元素
    refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
    addVnodes(
      parentElm,
      refElm,
      newCh,
      newStartIdx,
      newEndIdx,
      insertedVnodeQueue
    );
  } else if (newStartIdx > newEndIdx) {
    // 删除元素 在新子元素个数少于旧子元素个数时 删除多余的元素
    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
  }
}
```

### Vue 指令详解

#### v-for

> 主要方法 processFor -> parseFor 之后将其解析成 ast 数的格式 然后在进行 render 模板渲染

```javascript
function processFor(el) {
  var exp;
  //获取v-for指令 属性
  if ((exp = getAndRemoveAttr(el, "v-for"))) {
    // exp 为转换后获取的 指令内容
    // <div v-for="(item,index) of testArr">  </div>
    // 那么 exp 则为  (item,index) in testArr

    // 将其转换后并且在虚拟dom上删除这个v-for 属性
    var res = parseFor(exp);
    //转换 for指令 获取 for中的key  返回一个res对象为
    // {
    //   alias: "item"
    //   for: "testArr"
    //   iterator1: "index"
    //   iterator2: "key"   // 如果(item,index，key) in testArr 那么还有第二个遍历器为key
    // }
    if (res) {
      //合并浅拷贝到el中
      extend(el, res);
    } else {
      warn$2("Invalid v-for expression: " + exp);
    }
  }
}
// 最终的element 上有v-for 的虚拟dom应该为这个样子 AST
{
  "alias": "item",
  "iterator1": "index",
  "key": "index",
  "for": "testArr",

  "attrsList": [],
  "attrsMap": {v-for: "(item,index) in testArr", :key: "index"},
  "children": [],
  "forProcessed": true,
  "parent": {type: 1, tag: "div", attrsList: Array(1), attrsMap: {…}, parent: undefined, …}
  "plain": false,
  "static": false,
  "staticRoot": false,
  "tag": "div",
  "type": 1,
}

// v-for in   v-for  of 区别
```

- v-for ... of v-for ... in 区别

#### v-show

#### v-if

## JavaScript

### JS 防抖和节流

```javascript
// 防抖
// 多由于输入框或按钮 防止多次重复点击 导致接口等多次请求

function debounce(func, wait) {
  let timer = null;
  let _this = this;
  return function (...args) {
    clearTimeout(timer);
    timer = setTimeout(function () {
      func.apply(_this, args);
    }, wait);
  };
}

// 节流
// 多用于持续开销的方法或函数 比如滑动 减小性能消耗
function throttle(func, wait) {
  let timer = null;
  let _this = this;
  return function (...args) {
    if (!timer) {
      setTimeout(function () {
        func.apply(_this, args);
        timer = null;
      }, wait);
    }
  };
}
```

### 原型与原型链

```javascript
// 例1
function Person(name, age) {
  this.name = name || "default";
  this.age = age || 18;
}

Person.prototype.say = function () {
  console.log("hi");
};

var person = new Person("jack", 22);
```

#### 1. 原型对象 即 Person.prototype

> 在 JavaScript 中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个 prototype 属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。

```javascript
Person.prototype.say = function () {
  console.log("hi");
};
// 原型对象 Person.prototype 只是一个普通对象
// 在默认情况下，所有的原型对象都会自动获得一个 constructor（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数（Person）
person.constructor = Person;
// person 是Person 函数的实例
Person.prototype.constructor === Person;
// 所有Person.prototype 也是 Person的实例

// 可以理解为在函数创建的时候 创建了一个Person的实例 并把实例赋值给了 Person.prototype
var a = new Person();
Person.prototype = A;
```

#### 2. 原型链 \_\_proto\_\_

> 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到 Object 对象的原型，Object 对象的原型没有原型，如果在 Object 原型中依然没有找到，则返回 undefined。

> Object 是 JS 中所有对象数据类型的基类(最顶层的类)在 Object.prototype 上**proto** 为 NULL。

```javascript
Person.prototype.constructor == Person;
// 原型链指向的不是构造函数 而是构造函数的原型对象
// new 操作符做的也就是这个操作
person.__proto__ === Person.prototype;
person.constructor === Person;

// 例子
person.__proto__ === Person.prototype; // 指向的是person的构造函数的原型对象

Person.__proto__ === Function.prototype; // Person 由Function申明

Person.prototype.__proto__ === Object.prototype; // Person.protytype是一个普通对象 对象的构造函数原型是Object.prototype

Object.__proto__ === Function.prototype; // Object由Function构造  typeof Object  === 'function';

Object.prototype.__proto__ === null; // null 处于原型链的顶层
```

#### 3.函数对象

```javascript
Number.__proto__ === Function.prototype; // true
Number.constructor === Function; //true

Boolean.__proto__ === Function.prototype; // true
Boolean.constructor === Function; //true

String.__proto__ === Function.prototype; // true
String.constructor === Function; //true

// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身
Object.__proto__ === Function.prototype; // true
Object.constructor === Function; // true

// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身
Function.__proto__ === Function.prototype; // true
Function.constructor === Function; //true

Array.__proto__ === Function.prototype; // true
Array.constructor === Function; //true

RegExp.__proto__ === Function.prototype; // true
RegExp.constructor === Function; //true

Error.__proto__ === Function.prototype; // true
Error.constructor === Function; //true

Date.__proto__ === Function.prototype; // true
Date.constructor === Function; //true

// JavaScript中有内置(build-in)构造器/对象共计12个（ES5中新加了JSON），这里列举了可访问的8个构造器。剩下如Global不能直接访问，Arguments仅在函数调用时由JS引擎创建，Math，JSON是以对象形式存在的，无需new。它们的proto是Object.prototype

Math.__proto__ === Object.prototype; // true
Math.construrctor === Object; // true

JSON.__proto__ === Object.prototype; // true
JSON.construrctor === Object; //true

// 所有的构造器都来自于 Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了·Function.prototype·的属性及方法。如length、call、apply、bind
// 而 Function.prototype 为空函数 （Empty function）

console.log(typeof Function.prototype); // function
console.log(typeof Object.prototype); // object
console.log(typeof Number.prototype); // object
console.log(typeof Boolean.prototype); // object
console.log(typeof String.prototype); // object
console.log(typeof Array.prototype); // object
console.log(typeof RegExp.prototype); // object
console.log(typeof Error.prototype); // object
console.log(typeof Date.prototype); // object
console.log(typeof Object.prototype); // object

Function.prototype.__proto__ === Object.prototype; // true

// 说明函数的原型链指向的都是普通对象
// 这说明所有的构造器也都是一个普通 JS 对象，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等
```

```javascript
function Person(name, age) {
  this.name = name || "default";
  this.age = age || 18;
}

Person.prototype.say = function () {
  console.log("hi");
};

var person = new Person("jack", 22);

person.__proto__ === Person.prototype; // true;
person.__proto__ === person.constructor.prototype; // true

// 重写 Person.prototype
function Person(name, age) {
  this.name = name || "default";
  this.age = age || 18;
}

Person.prototype = {
  say: function () {},
};

var person = new Person("jack", 22);
person.__proto__ === Person.prototype; // true;
person.__proto__ === person.constructor.prototype; // false

// 因为重写了 Person.prototype  perosn.constructor === Object
// 而 Object.prototype === {}.__proto__
```

[参考链接](https://www.jianshu.com/p/a4e1e7b6f4f8)

### 深拷贝

#### 1. 转换为 JSON

```javascript
JSON.parse(JSON.stringfy(obj));
```

#### 2. 手写递归

```javascript
function deepClone(object) {
  let obj;
  if (object && typeof object === "object") {
    if (toString.call(object) === "[object Object]") {
      obj = {};
      for (let i in object) {
        obj[i] = deepClone(object[i]);
      }
    } else if (object.constructor === Array) {
      obj = [];
      for (let item of object) {
        obj.push(deepClone(item));
      }
    } else {
      return object;
    }
  } else {
    return object;
  }
  return obj;
}
```

#### 3. Object.assign()

> Object.assign 内部也是浅拷贝 只能深拷贝一层

### Array.prototype.slice.call(aruments) 原理

1. arguments 定义

> arguments 是一个对应于传递给函数的参数的类数组对象。 在所有函数中（非箭头函数）都有这个对象

```javascript
typeof arguments === "object";
Object.prototype.toString.call(argumnets) === "[object Arguments]";
```

2. Array.prototype.slice.call()

> Array.prototype.slice.call(aruments) 可以将 arguments 转化为数组类型

```javascript
// slice 源码 大致实现

Array.prototype.mySlice = function (start, end) {
  // Array.prototype.slice.call(aruments) 修改了slice里的this指向
  var result = [];

  var begin = start || 0;
  var len = this.length;
  // behin 远小于 0   begin + len < 0  直接返回 0
  // 否则 从后往前倒数
  begin = begin >= 0 ? begin : Math.max(0, begin + len);
  var tail = typeof end == "number" ? Math.min(end, len) : len;
  if (tail < 0) {
    tail = tail + len;
  }
  var length = tail - begin;

  for (var i = 0; i < length; i++) {
    result.push(this[begin + i]);
  }

  return result;
};
```

---

### call apply 原理实现

1. 使用原生方法

```javascript
Function.prototype._call2 = function (...args /* 也可以使用args*/) {
  console.log("call2=====");
  var obj = arguments[0];
  // 若函数有返回值需返回
  return this.apply(obj, [...arguments].slice(1));
};

Function.prototype._apply2 = function (...args /* 也可以使用args*/) {
  console.log("apply2=====");
  var obj = arguments[0];
  var arg1 = arguments[1];
  // 防止不传第二个参数 ...arg1报错
  if (!arg1) {
    arg1 = [];
  }
  // 若函数有返回值需返回
  return this.call(obj, ...arg1);
};
```

2. 不使用原生方法

```javascript
// 当_call _apply 不传参的时候 ...arg 不是可迭代对象会报错
// ...args 和 arguments 几乎相等 不过arguments需要转化为数组对象
Function.prototype._call = function (...args) {
  console.log("call1=====");
  var obj = args[0] || window;
  obj.tempFn = this;
  var result = obj.tempFn(...[...args].slice(1));
  delete obj.tempFn;
  return result;
};

Function.prototype._apply = function (...args) {
  console.log("apply1=====");
  var obj = args[0] || window;
  obj.tempFn = this;
  // 兼容不传参处理
  var arg = args[1];
  if (!arg) {
    arg = [];
  }
  var result = obj.tempFn(...arg);
  delete obj.tempFn;
  return result;
};
```

3. 不使用原生方法 && 扩展运算符...

```javascript
// 不使用扩展运算符 只能取 arguments对象
Function.prototype._call3 = function () {
  // 完善 若arguments[0] 为基础数据对象

  var obj = new Object(arguments[0]) || window;
  var arg2 = [];
  for (var i = 1; i < arguments.length; i++) {
    arg2.push("arguments[" + i + "]");
  }
  obj.tempFn = this;
  // 使用eval 隐式转换
  var result = eval("obj.tempFn(" + arg2 + ")");
  delete obj.tempFn;
  return result;
};

Function.prototype._apply3 = function () {
  var obj = new Object(arguments[0]) || window;
  var arg2 = [];
  obj.tempFn = this;
  // if (arguments[1]) {
  //   for (var i = 0; i < arguments[1].length; i++) {
  //     arg2.push("arguments[1][" + i + "]");
  //   }
  // }
  // var result = eval("obj.tempFn(" + arg2 + ")");
  var result = eval("obj.tempFn(" + arguments[1] + ")");
  delete obj.tempFn;
  return result;
};
```

## css

### BFC

> BFC(Block Formatting Context)块级格式化上下文，是用于布局块级盒子的一块渲染区域。MDN 上的解释：BFC 是 Web 页面 CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。

> 一个 BFC 的范围包含创建该上下文元素的所有子元素，但不包括创建了新 BFC 的子元素的内部元素。这从另一方角度说明，一个元素不能同时存在于两个 BFC 中。因为如果一个元素能够同时处于两个 BFC 中，那么就意味着这个元素能与两个 BFC 中的元素发生作用，就违反了 BFC 的隔离作用。

#### BFC 触发方式

1. 根元素，即 HTML 标签
2. 浮动元素：float 值为 left、right
3. overflow 值不为 visible，为 auto、scroll、hidden
4. display 值为 inline-block、table-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid
5. 定位元素：position 值为 absolute、fixed

> 注意：display:table 也可以生成 BFC 的原因在于 Table 会默认生成一个匿名的 table-cell，是这个匿名的 table-cell 生成了 BFC。

#### 浏览器对 BFC 区域的约束规则

1. 内部的 Box 会在垂直方向上一个接一个的放置
2. 内部的 Box 垂直方向上的距离由 margin 决定。（完整的说法是：属于同一个 BFC 的两个相邻 Box 的 margin 会发生折叠，不同 BFC 不会发生折叠。）
3. 每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明 BFC 中子元素不会超出他的包含块，而 position 为 absolute 的元素可以超出他的包含块边界）
4. BFC 的区域不会与 float 的元素区域重叠
5. 计算 BFC 的高度时，浮动子元素也参与计算
