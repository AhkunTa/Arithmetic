# 动态规划题型总结


## 1 路径类问题

###常见的题目如 #62 #63 #64 

###1. #62
>  机器人每次只能**向下或者向右**移动一步。问总共有多少条不同的路径？

#### 动态规划问题主要找到他的状态转移方程 注意题干加粗部分 只能向下或者向右 那么状态转移方程就很好解了

		到达当前地区dp[i][j]的不同路径数 等于 当前右边路径数加上当前上边路径数 
		dp[i][j] = dp[i-1][j] + dp[i][j-1];


####2. #63
#### 63的问题比62题只是加了一个障碍物既然如此 状态转移方程也需要修改
>  obstacleGrid[i][j] == 1 --> 即有障碍 dp[i][j] = 0  --> 即不通过   **dp[i][j] = dp[i-1][j] + dp[i][j-1]**
#### 只需判断一下 当有障碍时 通过的路线为 0 

###3. #64

#### 64的问题和62类似不过加上了每一步走到区域会有数字，求走到终点数字之和最小
> 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小

	dp[i][j] 当前数字之和
	grid[i][j] 当前数字
	
	所以 当前数字之和等于 当前数字加上 当前左边数字或者上边数字的最小值
	dp[i][j] =grid[i][j]  + Math.min(dp[i-1][j], dp[i][j-1]);

##2 上楼梯类型

### 常见题目如 #91

> 爬楼梯问题，一共有n个台阶，一次只能向上走一阶或者两阶，问一共有多少种走法？
这是个很经典的动态规划问题，用dp[n]表示爬完n个台阶的方法总数，那么最后一步可能是走了一阶，也可能是走了两阶，而走了一阶的方法总数等于爬完n-1个台阶的方法综述，最后一步走两阶的方法综述等于爬完n-2阶方法总数，因此不考虑边界的话可以有公式：dp[n] = dp[n-1]+dp[n-2]

#### 而#91除了爬楼梯外还要加上考虑边界情况，特别是为0的情况,不过状态转移方程是一样的。
 		 dp[i]为字符串的译码方法总数
 		 分情况讨论
 		 1 若s[i]= 0 那么 s[i-1] = 1 或 2 则dp[i] = dp[i-2] 即 当为10 20 时 只有一种方法编译 
		 否则 返回 0  因为 30 40 50 都没法编译
 		 2 若s[i-1] = 1 则 dp[i] = dp[i-1] + dp[i-2]
		 当有两位时 s[i-1] 必须为1 或者2 当大于2时 没有符合条件的
		 3 若s[i-1] = 2 && s[i] <= 6 dp[i] = dp[i-1] + dp[i-2]
		 同上

## 3 打家劫舍(其实也是路径类问题)

[团灭打家劫舍问题](https://leetcode-cn.com/problems/house-robber-ii/solution/tong-yong-si-lu-tuan-mie-da-jia-jie-she-wen-ti-by-/)


##### 打家劫舍Ⅰ #198
> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

#### 每次不能偷相邻的房屋

> 所偷窃的最大值 = MAX( 前面偷窃的最大值加上当前偷窃的金额 , 和当前最大值比较 ) 

> maxValue = nums[key] + curValue(循环中将maxValue暂存为curValue)

	
	// 输入: [1,2,3,1]
	// 输出: 4
	// 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
	//      偷窃到的最高金额 = 1 + 3 = 4 。
	// 示例 2:
	
	// 输入: [2,7,9,3,1]
	// 输出: 12
	// 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
	//      偷窃到的最高金额 = 2 + 9 + 1 = 12 。

		var rob = function(nums) {
		    var maxValue = 0;
		    var curValue = 0;
		    for(var key in nums){
		        var temp = maxValue;
		        maxValue = Math.max(curValue + nums[key],maxValue);
		        curValue = temp;
		    }
		    return maxValue;
		};


##### 打家劫舍Ⅱ#213
>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

		// 输入: [2,3,2]
		// 输出: 3
		// 解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
		// 示例 2:
		
		// 输入: [1,2,3,1]
		// 输出: 4
		// 解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
		//      偷窃到的最高金额 = 1 + 3 = 4 。
		
		
		// 和打家劫舍原题 198一样的思路不过围成了一个圈
		// 循环两次 第一次循环到0 - n-1 第二次 1 - n 选择两者中最大值
		// 状态转移方程 和 198 一样
		var rob = function(nums) {
		    if(nums.length == 0 ) return 0;
		    if(nums.length == 1 ) return nums[0];
		    // 使用一个数组 降低空间复杂度
			let dp = Array.from(new Array(nums.length )).fill(0);
		    let maxValue;
		    dp[0] = nums[0];
		    dp[1] = Math.max( nums[1], nums[0])
		    for(let i=2; i<nums.length-1; i++){
		        dp[i] = Math.max(dp[i-1], nums[i] + dp[i-2])
		    }
		    // 最大的值为length-2
		    maxValue = dp[nums.length-2];
		    // 重置元素
		    dp[0] = 0;
		    dp[1] = nums[1]
		    for(let j=2; j<nums.length; j++){
		        dp[j] = Math.max(dp[j-1], nums[j] + dp[j-2])
		    }
		    return Math.max(maxValue,dp[nums.length-1])
		};


##### 打家劫舍Ⅲ #337
> 在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

> 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

	 示例 1:
	
	输入: [3,2,3,null,3,null,1]
	
	     3
	    / \
	   2   3
	    \   \ 
	     3   1
	
	输出: 7 
	解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
	示例 2:
	
	输入: [3,4,5,1,3,null,1]
	
	     3
	    / \
	   4   5
	  / \   \ 
	 1   3   1
	
	输出: 9
	解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.



		var rob = function(root) {
		  function bst(node) {
		    let curr = [0, 0];
		    if (!node) return curr;
		    
		    let left = bst(node.left),
		        right = bst(node.right);
		    
		    // 当前点没有偷的最大值 = 左节点偷或不偷的最大值 + 右节点偷或不偷的最大值
		    curr[0] = Math.max(...left) + Math.max(...right);
		    
		    // 当前点偷了的最大值 = 它的左右节点没有偷的最大值加上当前点的值
		    curr[1] = node.val + left[0] + right[0];
		    
		    return curr;
		  }
		  
		  let ans = bst(root);
		  return Math.max(ans[0], ans[1]);
		}