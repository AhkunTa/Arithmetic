# 动态规划题型总结


## 1 路径类问题

###常见的题目如 #62 #63 #64 

###1. #62
>  机器人每次只能**向下或者向右**移动一步。问总共有多少条不同的路径？

#### 动态规划问题主要找到他的状态转移方程 注意题干加粗部分 只能向下或者向右 那么状态转移方程就很好解了

		到达当前地区dp[i][j]的不同路径数 等于 当前右边路径数加上当前上边路径数 
		dp[i][j] = dp[i-1][j] + dp[i][j-1];


####2. #63
#### 63的问题比62题只是加了一个障碍物既然如此 状态转移方程也需要修改
>  obstacleGrid[i][j] == 1 --> 即有障碍 dp[i][j] = 0  --> 即不通过   **dp[i][j] = dp[i-1][j] + dp[i][j-1]**
#### 只需判断一下 当有障碍时 通过的路线为 0 

###3. #64

#### 64的问题和62类似不过加上了每一步走到区域会有数字，求走到终点数字之和最小
> 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小

	dp[i][j] 当前数字之和
	grid[i][j] 当前数字
	
	所以 当前数字之和等于 当前数字加上 当前左边数字或者上边数字的最小值
	dp[i][j] =grid[i][j]  + Math.min(dp[i-1][j], dp[i][j-1]);

##2 上楼梯类型

### 常见题目如 #91

> 爬楼梯问题，一共有n个台阶，一次只能向上走一阶或者两阶，问一共有多少种走法？
这是个很经典的动态规划问题，用dp[n]表示爬完n个台阶的方法总数，那么最后一步可能是走了一阶，也可能是走了两阶，而走了一阶的方法总数等于爬完n-1个台阶的方法综述，最后一步走两阶的方法综述等于爬完n-2阶方法总数，因此不考虑边界的话可以有公式：dp[n] = dp[n-1]+dp[n-2]

#### 而#91除了爬楼梯外还要加上考虑边界情况，特别是为0的情况,不过状态转移方程是一样的。
 		 dp[i]为字符串的译码方法总数
 		 分情况讨论
 		 1 若s[i]= 0 那么 s[i-1] = 1 或 2 则dp[i] = dp[i-2] 即 当为10 20 时 只有一种方法编译 
		 否则 返回 0  因为 30 40 50 都没法编译
 		 2 若s[i-1] = 1 则 dp[i] = dp[i-1] + dp[i-2]
		 当有两位时 s[i-1] 必须为1 或者2 当大于2时 没有符合条件的
		 3 若s[i-1] = 2 && s[i] <= 6 dp[i] = dp[i-1] + dp[i-2]
		 同上

## 3 打家劫舍(其实也是路径类问题)

[团灭打家劫舍问题](https://leetcode-cn.com/problems/house-robber-ii/solution/tong-yong-si-lu-tuan-mie-da-jia-jie-she-wen-ti-by-/)

> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

#### 每次不能偷相邻的房屋

> 所偷窃的最大值 = MAX( 前面偷窃的最大值加上当前偷窃的金额 , 和当前最大值比较 ) 

> maxValue = nums[key] + curValue(循环中将maxValue暂存为curValue)